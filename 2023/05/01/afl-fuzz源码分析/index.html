<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="afl-fuzz源码分析GCC编译流程">
<meta property="og:type" content="article">
<meta property="og:title" content="afl-fuzz源码分析">
<meta property="og:url" content="http://example.com/2023/05/01/afl-fuzz%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/index.html">
<meta property="og:site_name" content="Ash blog">
<meta property="og:description" content="afl-fuzz源码分析GCC编译流程">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2023/05/01/afl-fuzz%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/GCC_CompilationProcess-1684644951742-3.png">
<meta property="article:published_time" content="2023-05-01T06:44:17.376Z">
<meta property="article:modified_time" content="2023-07-01T14:18:00.723Z">
<meta property="article:author" content="Ash">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2023/05/01/afl-fuzz%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/GCC_CompilationProcess-1684644951742-3.png">

<link rel="canonical" href="http://example.com/2023/05/01/afl-fuzz%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>afl-fuzz源码分析 | Ash blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Ash blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/05/01/afl-fuzz%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ash">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ash blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          afl-fuzz源码分析
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-05-01 14:44:17" itemprop="dateCreated datePublished" datetime="2023-05-01T14:44:17+08:00">2023-05-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-07-01 22:18:00" itemprop="dateModified" datetime="2023-07-01T22:18:00+08:00">2023-07-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="afl-fuzz源码分析"><a href="#afl-fuzz源码分析" class="headerlink" title="afl-fuzz源码分析"></a>afl-fuzz源码分析</h1><h2 id="GCC编译流程"><a href="#GCC编译流程" class="headerlink" title="GCC编译流程"></a>GCC编译流程</h2><p> <img src="/2023/05/01/afl-fuzz%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/GCC_CompilationProcess-1684644951742-3.png" alt="C_complie"></p>
<ol>
<li>预处理（Preprocessing）：对源代码进行预处理，如宏替换、条件编译等，生成经过预处理的源代码。预处理可以通过<code>gcc -E</code>命令单独执行。</li>
<li>编译（Compilation）：将预处理后的源代码翻译成汇编代码（Assembly code），生成<code>.s</code>文件。编译可以通过<code>gcc -S</code>命令单独执行。</li>
<li>汇编（Assembly）：将汇编代码翻译成机器语言的二进制指令（Object code），生成<code>.o</code>文件。汇编可以通过<code>as</code>程序单独执行。</li>
<li>链接（Linking）：将多个<code>.o</code>文件或库文件（如<code>.a</code>或<code>.so</code>）链接成可执行程序或共享库文件，生成最终的二进制文件。链接可以通过<code>ld</code>程序单独执行，但通常由GCC自动调用。</li>
</ol>
<h2 id="1-afl-gcc"><a href="#1-afl-gcc" class="headerlink" title="1.afl-gcc"></a>1.afl-gcc</h2><p>afl-gcc本身是gcc编译器的封装,通过afl的一些环境变量,设置一些gcc的编译选项,如asan,msan,编译器优化等,指定汇编器为afl-as,生成ob code.</p>
<h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a><strong>全局变量</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> u8*  as_path;                <span class="comment">/* Path to the AFL &#x27;as&#x27; wrapper      */</span></span><br><span class="line"><span class="type">static</span> u8** cc_params;              <span class="comment">/* Parameters passed to the real CC  */</span></span><br><span class="line"><span class="type">static</span> u32  cc_par_cnt = <span class="number">1</span>;         <span class="comment">/* Param count, including argv0      */</span></span><br><span class="line"><span class="type">static</span> u8   be_quiet,               <span class="comment">/* Quiet mode                        */</span></span><br><span class="line">            clang_mode;             <span class="comment">/* Invoked as afl-clang*?            */</span></span><br></pre></td></tr></table></figure>

<p>as_path:afl-as的路径</p>
<p>cc_params:调用gcc或者clang的参数</p>
<p>cc_par_cnt:gcc clang参数数量</p>
<p>be_quiet:静默模式</p>
<p>clang_mode:是否使用afl-clang</p>
<h3 id="main"><a href="#main" class="headerlink" title="main"></a><strong>main</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isatty(<span class="number">2</span>) &amp;&amp; !getenv(<span class="string">&quot;AFL_QUIET&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">    SAYF(cCYA <span class="string">&quot;afl-cc &quot;</span> cBRI VERSION cRST <span class="string">&quot; by &lt;lcamtuf@google.com&gt;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> be_quiet = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line"></span><br><span class="line">    SAYF(<span class="string">&quot;\n&quot;</span></span><br><span class="line">         <span class="string">&quot;This is a helper application for afl-fuzz. It serves as a drop-in replacement\n&quot;</span></span><br><span class="line">         <span class="string">&quot;for gcc or clang, letting you recompile third-party code with the required\n&quot;</span></span><br><span class="line">         <span class="string">&quot;runtime instrumentation. A common use pattern would be one of the following:\n\n&quot;</span></span><br><span class="line"></span><br><span class="line">         <span class="string">&quot;  CC=%s/afl-gcc ./configure\n&quot;</span></span><br><span class="line">         <span class="string">&quot;  CXX=%s/afl-g++ ./configure\n\n&quot;</span></span><br><span class="line"></span><br><span class="line">         <span class="string">&quot;You can specify custom next-stage toolchain via AFL_CC, AFL_CXX, and AFL_AS.\n&quot;</span></span><br><span class="line">         <span class="string">&quot;Setting AFL_HARDEN enables hardening optimizations in the compiled code.\n\n&quot;</span>,</span><br><span class="line">         BIN_PATH, BIN_PATH);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  find_as(argv[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">  edit_params(argc, argv);</span><br><span class="line"></span><br><span class="line">  execvp(cc_params[<span class="number">0</span>], (<span class="type">char</span>**)cc_params);</span><br><span class="line"></span><br><span class="line">  FATAL(<span class="string">&quot;Oops, failed to execute &#x27;%s&#x27; - check your PATH&quot;</span>, cc_params[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>be_quiet为1时,不会打印程序输出信息</p>
<p>主要功能集中在find_as,edit_params函数,最后执行execvp</p>
<h3 id="find-as"><a href="#find-as" class="headerlink" title="find_as"></a>find_as</h3><p>函数功能是寻找伪造的gcc-as(afl-as)汇编程序,实际上是通过环境变量”AFL_PATH”或者afl-gcc的当前执行目录寻找afl-as的路径.</p>
<h3 id="edit-params"><a href="#edit-params" class="headerlink" title="edit_params"></a>edit_params</h3><p>函数功能是,将argv的参数复制到cc_params,以及做一些参数的处理.</p>
<p>首先alloc给cc_params一个(argc+128)*8字节大小的内存</p>
<p>1.检查当前执行程序名是否为afl-clangxx,如果是</p>
<p>​	clang_mode&#x3D;1,表示使用afl-clang模式</p>
<p>​	如果是clang++</p>
<p>​	尝试获取AFL_CXX环境变量.或者使用默认值”clang++”,赋值给cc_params[0]</p>
<p>​	如果不是clang++</p>
<p>​	尝试获取AFL_CC环境变量.或者使用默认值”clang”,赋值给cc_params[0]</p>
<p>如果不是afl-clangxx,会认为是apple平台并做一些处理,这里不做赘述.</p>
<p>2.while循环,遍历argv[1]和之后的参数,做一些处理.</p>
<p>参数:-B是否指定了汇编器afl-as的路径,如果是默认模式,直接跳过.</p>
<p>参数:-integrated-as和-pipe 直接跳过不做处理.</p>
<p>参数:-fsanitize&#x3D;address和-fsanitize&#x3D;memory,gcc的编译选项,LLVM的组件Asan,将asan_set&#x3D;1,这两个参数是Asan用于检测内存访问越界,内存泄露问题的.如果编译时插入一些安全检查,需要记录和跟踪信息,可以加上.</p>
<p>参数:FORTIFY_SOURCE,将fortify_set &#x3D; 1,gcc编译时会在一些容易出现漏洞的函数插入一些安全检查,如memcpy,strcpy…</p>
<p>3.while结束,对前面做的一些标记做参数处理.</p>
<p>-B as_path,find_as里面寻找到的afl-as路径.</p>
<p>clang_mode为1 设置-no-integrated-as</p>
<p>如果环境变量存在AFL_HARDEN.设置gcc -fstack-protector-all和-D_FORTIFY_SOURCE&#x3D;2,这个afl的编译选项,会开启一些编译时的安全保护.<br>如果asan_set为1,设置了些编译时的内存错误检测,设置环境变量AFL_USE_ASAN为1</p>
<p>编译选项asan和msan相关,添加这些编译选项,利于内存错误的分析</p>
<p>获取环境变量AFL_USE_ASAN,AFL_USE_MSAN,AFL_HARDEN,设置了一些-U_FORTIFY_SOURCE和-fsanitize&#x3D;memory参数,只是此处AFL_USE_ASAN和AFL_USE_MSAN不能同时设置,因为使用asan和msan编译同一源代码时,会对运行速度造成影响,afl-fuzz可能会觉得对效率有影响</p>
<p>编译器优化相关,添加这些编译选项,禁止编译优化,利于afl-fuzz更好的探测一些漏洞,但是程序会变慢,可能会对fuzz效率造成影响.</p>
<p>获取环境变量AFL_DONT_OPTIMIZE,存在</p>
<p>设置gcc编译选项-g -O3 -funroll-loops -D__AFL_COMPILER&#x3D;1 -DFUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION&#x3D;1</p>
<p>编译器内置函数优化相关的一些编译选项,内置函数可能不安全,禁用可能会导致程序变慢.</p>
<p>获取环境变量AFL_NO_BUILTIN,存在</p>
<p>一些函数不使用编译器内置的,如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cc_params[cc_par_cnt++] = <span class="string">&quot;-fno-builtin-strcmp&quot;</span>;</span><br><span class="line">cc_params[cc_par_cnt++] = <span class="string">&quot;-fno-builtin-strncmp&quot;</span>;</span><br><span class="line">cc_params[cc_par_cnt++] = <span class="string">&quot;-fno-builtin-strcasecmp&quot;</span>;</span><br><span class="line">cc_params[cc_par_cnt++] = <span class="string">&quot;-fno-builtin-strncasecmp&quot;</span>;</span><br><span class="line">cc_params[cc_par_cnt++] = <span class="string">&quot;-fno-builtin-memcmp&quot;</span>;</span><br><span class="line">cc_params[cc_par_cnt++] = <span class="string">&quot;-fno-builtin-strstr&quot;</span>;</span><br><span class="line">cc_params[cc_par_cnt++] = <span class="string">&quot;-fno-builtin-strcasestr&quot;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="execvp-cc-params-0-char-cc-params"><a href="#execvp-cc-params-0-char-cc-params" class="headerlink" title="execvp(cc_params[0], (char**)cc_params);"></a>execvp(cc_params[0], (char**)cc_params);</h3><p>afl-fuzz目录下会有一个as的连接,指向afl-as,gcc编译时,汇编器指定了afl-fuzz目录,会自动寻找as,从而执行afl-as,简而言之,就是代替了系统的汇编器as</p>
<p>执行gcc, 指定汇编器为afl-fuzz目录下的as(afl-as)进行汇编,,带上设置好的参数.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(cc_params); ++i) &#123;</span><br><span class="line">    SAYF(<span class="string">&quot;%s &quot;</span>, *(cc_params + i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc ../testc.c -o ../testc -B /home/ash/code/afl-fuzz -g -O3 -funroll-loops -D__AFL_COMPILER=1 -DFUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION=1</span><br></pre></td></tr></table></figure>



<h2 id="2-afl-as"><a href="#2-afl-as" class="headerlink" title="2.afl-as"></a>2.afl-as</h2><p>afl-as是gas汇编器的封装.</p>
<h3 id="全局变量-1"><a href="#全局变量-1" class="headerlink" title="全局变量"></a>全局变量</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> u8** as_params;          <span class="comment">/* Parameters passed to the real &#x27;as&#x27;   */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> u8*  input_file;         <span class="comment">/* Originally specified input file      */</span></span><br><span class="line"><span class="type">static</span> u8*  modified_file;      <span class="comment">/* Instrumented file for the real &#x27;as&#x27;  */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> u8   be_quiet,           <span class="comment">/* Quiet mode (no stderr output)        */</span></span><br><span class="line">            clang_mode,         <span class="comment">/* Running in clang mode?               */</span></span><br><span class="line">            pass_thru,          <span class="comment">/* Just pass data through?              */</span></span><br><span class="line">            just_version,       <span class="comment">/* Just show version?                   */</span></span><br><span class="line">            sanitizer;          <span class="comment">/* Using ASAN / MSAN                    */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> u32  inst_ratio = <span class="number">100</span>,   <span class="comment">/* Instrumentation probability (%)      */</span></span><br><span class="line">            as_par_cnt = <span class="number">1</span>;     <span class="comment">/* Number of params to &#x27;as&#x27;             */</span></span><br></pre></td></tr></table></figure>

<p>as_params:gcc传递给as的参数</p>
<p>input_file:指定输入文件</p>
<p>modified_file:afl-as输出的插桩后的汇编文件</p>
<p>be_quiet:静默模式</p>
<p>clang_mode:clang编译模式</p>
<p>pass_thru:是否在汇编时不做插桩.</p>
<p>just_version:只显示版本</p>
<p>sanitizer:使用asan&#x2F;msan</p>
<p>inst_ratio:插桩代码的比例.</p>
<p>as_par_cnt:指定线程运行afl-as</p>
<h3 id="main-1"><a href="#main-1" class="headerlink" title="main"></a>main</h3><p>gcc传递过来的参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/home/ash/code/afl-fuzz/as --gdwarf-5 --64 -o /tmp/ccQwLzYy.o /tmp/ccw6hnjr.s </span><br></pre></td></tr></table></figure>

<p>首先从环境变量中获取AFL_INST_RATIO,赋值给inst_ratio_str,这个变量代表插桩频率,如果为100,则在每个块中都会插入插桩代码,如果为0,则只插桩函数入口的块.</p>
<p>获取当前时间,pid,计算成一个rand_seed,生成随机数.</p>
<p>edit_params函数对参数进行处理</p>
<p>获取环境变量AS_LOOP_ENV_VAR,这个环境变量是afl-as重复汇编的次数,默认设置为1.为了解决插桩可能会导致的执行异常情况,多次通过随机值插桩,避免程序出现异常.</p>
<p>通过检查环境变量AFL_USE_ASAN,AFL_USE_MSAN,判断是否存在这些编译选项,将sanitizer设置为1,并将inst_ratio&#x2F;3,这里做了处理原因如果开启了asan或者msan会导致程序的分支增多,在插桩到这些分支,然后执行,是没有意义的.所以这里直接做了除3处理,将比例减小.</p>
<p>执行add_instrumentation函数,开始插桩</p>
<p>fork一个子进程执行gas进行汇编,参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">as --gdwarf-5 --64 -o /tmp/ccQwLzYy.o /tmp/.afl-1040-1683019150.s </span><br></pre></td></tr></table></figure>

<p>gas执行结束后,检测环境变量AFL_KEEP_ASSEMBLY,如果没有就删除掉插桩的汇编文件.</p>
<h3 id="edit-params-1"><a href="#edit-params-1" class="headerlink" title="edit_params"></a>edit_params</h3><p>主要是做as的参数处理,构造汇编文件名参数,架构,赋值input_file&#x3D;汇编文件.</p>
<h3 id="add-instrumentation"><a href="#add-instrumentation" class="headerlink" title="add_instrumentation"></a>add_instrumentation</h3><p>插桩函数</p>
<p>首先获取需要插桩的汇编文件赋值于inputfile,而后在本地创建插桩文件modified_file,并打开赋值于outf.</p>
<p>逐行读取至line数组中,然后做一些条件判断,跳过标签,宏,注释这些不需要插桩的地方,这里是通过一些标志位判断的.</p>
<p>输入代码到modified_file.</p>
<p>对当前读取到的区段进行判断,如果为.text相关的区段,将标志位instr_ok修改为1,表示将对代码分支进行插桩.</p>
<p>如果为bss,data这些数据段,标志为0,不会进行插桩.</p>
<p>如果为p2align宏,将标志位skip_next_label更改为1.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (line[<span class="number">0</span>] == <span class="string">&#x27;\t&#x27;</span> &amp;&amp; line[<span class="number">1</span>] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* OpenBSD puts jump tables directly inline with the code, which is</span></span><br><span class="line"><span class="comment">           a bit annoying. They use a specific format of p2align directives</span></span><br><span class="line"><span class="comment">           around them, so we use that as a signal. */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!clang_mode &amp;&amp; instr_ok &amp;&amp; !<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;p2align &quot;</span>, <span class="number">8</span>) &amp;&amp;</span><br><span class="line">            <span class="built_in">isdigit</span>(line[<span class="number">10</span>]) &amp;&amp; line[<span class="number">11</span>] == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">            skip_next_label = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;text\n&quot;</span>, <span class="number">5</span>) ||</span><br><span class="line">            !<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;section\t.text&quot;</span>, <span class="number">13</span>) ||</span><br><span class="line">            !<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;section\t__TEXT,__text&quot;</span>, <span class="number">21</span>) ||</span><br><span class="line">            !<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;section __TEXT,__text&quot;</span>, <span class="number">21</span>)) &#123;</span><br><span class="line">            instr_ok = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;section\t&quot;</span>, <span class="number">8</span>) ||</span><br><span class="line">            !<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;section &quot;</span>, <span class="number">8</span>) ||</span><br><span class="line">            !<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;bss\n&quot;</span>, <span class="number">4</span>) ||</span><br><span class="line">            !<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;data\n&quot;</span>, <span class="number">5</span>)) &#123;</span><br><span class="line">            instr_ok = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>检测是否为.code段,如果为.code32,需要跳过,.code64不跳过.</p>
<p>如果为.intel_syntax,需要跳过,.att_syntax不跳过.</p>
<p>检测和跳过ad-hoc ___asm___代码块,#APP表示,进入代码块,需要跳过,#NO_APP表示结束,需要插桩.</p>
<p>这里做的处理是跳过一些不需要插桩的部分,确保程序不会出错.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;.code&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;.code32&quot;</span>)) skip_csect = use_64bit;</span><br><span class="line">         <span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;.code64&quot;</span>)) skip_csect = !use_64bit;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* Detect syntax changes, as could happen with hand-written assembly.</span></span><br><span class="line"><span class="comment">        Skip Intel blocks, resume instrumentation when back to AT&amp;T. */</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;.intel_syntax&quot;</span>)) skip_intel = <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;.att_syntax&quot;</span>)) skip_intel = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* Detect and skip ad-hoc __asm__ blocks, likewise skipping them. */</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (line[<span class="number">0</span>] == <span class="string">&#x27;#&#x27;</span> || line[<span class="number">1</span>] == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;#APP&quot;</span>)) skip_app = <span class="number">1</span>;</span><br><span class="line">         <span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;#NO_APP&quot;</span>)) skip_app = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>afl-fuzz插桩的范围</p>
<p> ^main: - 函数入口点<br>^.L0: - GCC分支标签<br>^.LBB0_0: - clang分支标签（但只在clang模式下）。<br>^tjnz foo - 条件跳转分支</p>
<p>总之,是主要的main函数,和条件分支指令前进行插桩,以此实现fuzz的路径覆盖率检测,其中又包含了对插桩比例的计算,随机数小于inst_ratio才会进行插桩.</p>
<p>而后将插桩指令写入至outfd,这里通过对架构进行了判断,以插入不同的桩代码,并生成了一个随机数写入R(MAP_SIZE),作为桩的编号,然后将ins_lines,插桩计数+1.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* If we&#x27;re in the right mood for instrumenting, check for function</span></span><br><span class="line"><span class="comment">          names or conditional labels. This is a bit messy, but in essence,</span></span><br><span class="line"><span class="comment">          we want to catch:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            ^main:      - function entry point (always instrumented)</span></span><br><span class="line"><span class="comment">            ^.L0:       - GCC branch label</span></span><br><span class="line"><span class="comment">            ^.LBB0_0:   - clang branch label (but only in clang mode)</span></span><br><span class="line"><span class="comment">            ^\tjnz foo  - conditional branches</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">          ...but not:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            ^# BB#0:    - clang comments</span></span><br><span class="line"><span class="comment">            ^ # BB#0:   - ditto</span></span><br><span class="line"><span class="comment">            ^.Ltmp0:    - clang non-branch labels</span></span><br><span class="line"><span class="comment">            ^.LC0       - GCC non-branch labels</span></span><br><span class="line"><span class="comment">            ^.LBB0_0:   - ditto (when in GCC mode)</span></span><br><span class="line"><span class="comment">            ^\tjmp foo  - non-conditional jumps</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">          Additionally, clang and GCC on MacOS X follow a different convention</span></span><br><span class="line"><span class="comment">          with no leading dots on labels, hence the weird maze of #ifdefs</span></span><br><span class="line"><span class="comment">          later on.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (skip_intel || skip_app || skip_csect || !instr_ok ||</span><br><span class="line">           line[<span class="number">0</span>] == <span class="string">&#x27;#&#x27;</span> || line[<span class="number">0</span>] == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">           <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/* Conditional branch instruction (jnz, etc). We append the instrumentation</span></span><br><span class="line"><span class="comment">          right after the branch (to instrument the not-taken path) and at the</span></span><br><span class="line"><span class="comment">          branch destination label (handled later on). */</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (line[<span class="number">0</span>] == <span class="string">&#x27;\t&#x27;</span>) &#123;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (line[<span class="number">1</span>] == <span class="string">&#x27;j&#x27;</span> &amp;&amp; line[<span class="number">2</span>] != <span class="string">&#x27;m&#x27;</span> &amp;&amp; R(<span class="number">100</span>) &lt; inst_ratio) &#123;</span><br><span class="line"></span><br><span class="line">               <span class="built_in">fprintf</span>(outf, use_64bit ? trampoline_fmt_64 : trampoline_fmt_32,</span><br><span class="line">                       R(MAP_SIZE));</span><br><span class="line"></span><br><span class="line">               ins_lines++;</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p>而后判断是否为<code>:</code>的判断,下个字符是否为<code>.</code>,如果不是,afl-as默认当作一个function.,将instrument_next更改为1.</p>
<p>如果是继续判断,是否为<code>.L</code>和<code>.LBB</code>这种需要插桩的跳转目标标签.</p>
<p>gnu编译器,通常以<code>.L0</code>开头,clang编译下,以<code>.LBB</code>开头,计算inst_ratio通过后,将instrument_next更改为1.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __APPLE__</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Apple: L&lt;whatever&gt;&lt;digit&gt;: */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((colon_pos = <span class="built_in">strstr</span>(line, <span class="string">&quot;:&quot;</span>))) &#123;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (line[<span class="number">0</span>] == <span class="string">&#x27;L&#x27;</span> &amp;&amp; <span class="built_in">isdigit</span>(*(colon_pos - <span class="number">1</span>))) &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Everybody else: .L&lt;whatever&gt;: */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;:&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (line[<span class="number">0</span>] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __APPLE__ */</span></span></span><br><span class="line"></span><br><span class="line">                <span class="comment">/* .L0: or LBB0_0: style jump destination */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __APPLE__</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">/* Apple: L&lt;num&gt; / LBB&lt;num&gt; */</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> ((<span class="built_in">isdigit</span>(line[<span class="number">1</span>]) || (clang_mode &amp;&amp; !<span class="built_in">strncmp</span>(line, <span class="string">&quot;LBB&quot;</span>, <span class="number">3</span>)))</span><br><span class="line">                    &amp;&amp; R(<span class="number">100</span>) &lt; inst_ratio) &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"></span><br><span class="line">                <span class="comment">/* Apple: .L&lt;num&gt; / .LBB&lt;num&gt; */</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> ((<span class="built_in">isdigit</span>(line[<span class="number">2</span>]) || (clang_mode &amp;&amp; !<span class="built_in">strncmp</span>(line + <span class="number">1</span>, <span class="string">&quot;LBB&quot;</span>, <span class="number">3</span>)))</span><br><span class="line">                    &amp;&amp; R(<span class="number">100</span>) &lt; inst_ratio) &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __APPLE__ */</span></span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* An optimization is possible here by adding the code only if the</span></span><br><span class="line"><span class="comment">                       label is mentioned in the code in contexts other than call / jmp.</span></span><br><span class="line"><span class="comment">                       That said, this complicates the code by requiring two-pass</span></span><br><span class="line"><span class="comment">                       processing (messy with stdin), and results in a speed gain</span></span><br><span class="line"><span class="comment">                       typically under 10%, because compilers are generally pretty good</span></span><br><span class="line"><span class="comment">                       about not generating spurious intra-function jumps.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                       We use deferred output chiefly to avoid disrupting</span></span><br><span class="line"><span class="comment">                       .Lfunc_begin0-style exception handling calculations (a problem on</span></span><br><span class="line"><span class="comment">                       MacOS X). */</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (!skip_next_label) instrument_next = <span class="number">1</span>; <span class="keyword">else</span> skip_next_label = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* Function label (always instrumented, deferred mode). */</span></span><br><span class="line"></span><br><span class="line">                instrument_next = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>最后,结束while循环.</p>
<p>判断ins_lines插桩数量不为0,则根据架构插入main_payload64或main_payload_32</p>
<p>而后释放资源.</p>
<h3 id="afl-as桩代码分析"><a href="#afl-as桩代码分析" class="headerlink" title="afl-as桩代码分析"></a>afl-as桩代码分析</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">lea     rsp, [rsp-98h]</span><br><span class="line">mov     [rsp+0A0h+var_A0], rdx</span><br><span class="line">mov     [rsp+0A0h+var_98], rcx</span><br><span class="line">mov     [rsp+0A0h+var_90], rax</span><br><span class="line">mov     rcx, 0D8FEh</span><br><span class="line">call    __afl_maybe_log</span><br><span class="line">mov     rax, [rsp+0A0h+var_90]</span><br><span class="line">mov     rcx, [rsp+0A0h+var_98]</span><br><span class="line">mov     rdx, [rsp+0A0h+var_A0]</span><br><span class="line">lea     rsp, [rsp+98h]</span><br></pre></td></tr></table></figure>

<p>保存rdc,rcx,rax寄存器状态</p>
<p>传入一个随机数至rcx,这个随机数是之前R(MAP_SIZE)产生的,调用__afl_maybe_log</p>
<p>恢复寄存器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.lcomm   __afl_area_ptr, 8</span><br><span class="line">.lcomm   __afl_prev_loc, 8</span><br><span class="line">.lcomm   __afl_fork_pid, 4</span><br><span class="line">.lcomm   __afl_temp, 4</span><br><span class="line">.lcomm   __afl_setup_failure, 1</span><br><span class="line">.comm    __afl_global_area_ptr, 8, 8</span><br></pre></td></tr></table></figure>

<p>通过<code>.comm</code>,<code>.lcomm</code>在bss段初始化的一些变量.</p>
<p>__afl_area_ptr:一块内存的指针,记录当前代码块的执行信息</p>
<p>__afl_prev_loc:记录上一个插桩的路径信息.</p>
<p>_afl_maybe_log首次执行流程:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.text:00005555555554F0 lahf</span><br><span class="line">.text:00005555555554F1 seto    al</span><br><span class="line">.text:00005555555554F4 mov     rdx, cs:__afl_area_ptr</span><br><span class="line">.text:00005555555554FB test    rdx, rdx</span><br><span class="line">.text:00005555555554FE jz      short __afl_setup</span><br></pre></td></tr></table></figure>

<p>首先执行lahf和 seto al将eflags寄存器的低8位(SF,ZF,AF,PF,CF)和OF保存到ax中.</p>
<p>判断<code>__afl_area_ptr</code>是否为0,为0执行<code>__afl_setup</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.text:0000555555555528 __afl_setup: </span><br><span class="line">.text:0000555555555528 cmp     cs:__afl_setup_failure, 0</span><br><span class="line">.text:000055555555552F jnz     short __afl_return</span><br><span class="line">.text:000055555555552F</span><br><span class="line">.text:0000555555555531 lea     rdx, __afl_global_area_ptr</span><br><span class="line">.text:0000555555555538 mov     rdx, [rdx]</span><br><span class="line">.text:000055555555553B test    rdx, rdx</span><br><span class="line">.text:000055555555553E jz      short __afl_setup_first</span><br></pre></td></tr></table></figure>

<p>继续判断<code>__afl_setup_failure</code>是否为0,不为0说明afl初始化时发生了错误,直接调用<code>__afl_return</code>还原,结束.</p>
<p>继续判断<code>afl_global_area_ptr</code>中指针指向的内存是否为0,如果为0,说明afl是首次执行,执行<code>__afl_setup_first</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">.text:0000555555555549 __afl_setup_first:                      ; CODE XREF: __afl_maybe_log+4E↑j</span><br><span class="line">.text:0000555555555549 lea     rsp, [rsp-160h]</span><br><span class="line">.text:0000555555555551 mov     [rsp+160h+var_160], rax</span><br><span class="line">.text:0000555555555555 mov     [rsp+160h+var_158], rcx</span><br><span class="line">.text:000055555555555A mov     [rsp+160h+var_150], rdi</span><br><span class="line">.text:000055555555555F mov     [rsp+160h+var_140], rsi</span><br><span class="line">.text:0000555555555564 mov     [rsp+160h+var_138], r8</span><br><span class="line">.text:0000555555555569 mov     [rsp+160h+var_130], r9</span><br><span class="line">.text:000055555555556E mov     [rsp+160h+var_128], r10</span><br><span class="line">.text:0000555555555573 mov     [rsp+160h+var_120], r11</span><br><span class="line">.text:0000555555555578 movq    [rsp+160h+var_100], xmm0</span><br><span class="line">.text:000055555555557E movq    [rsp+160h+var_F0], xmm1</span><br><span class="line">.text:0000555555555584 movq    [rsp+160h+var_E0], xmm2</span><br><span class="line">.text:000055555555558D movq    [rsp+160h+var_D0], xmm3</span><br><span class="line">.text:0000555555555596 movq    [rsp+160h+var_C0], xmm4</span><br><span class="line">.text:000055555555559F movq    [rsp+160h+var_B0], xmm5</span><br><span class="line">.text:00005555555555A8 movq    [rsp+160h+var_A0], xmm6</span><br><span class="line">.text:00005555555555B1 movq    [rsp+160h+var_90], xmm7</span><br><span class="line">.text:00005555555555BA movq    [rsp+160h+var_80], xmm8</span><br><span class="line">.text:00005555555555C4 movq    [rsp+160h+var_70], xmm9</span><br><span class="line">.text:00005555555555CE movq    [rsp+160h+var_60], xmm10</span><br><span class="line">.text:00005555555555D8 movq    [rsp+160h+var_50], xmm11</span><br><span class="line">.text:00005555555555E2 movq    [rsp+160h+var_40], xmm12</span><br><span class="line">.text:00005555555555EC movq    [rsp+160h+var_30], xmm13</span><br><span class="line">.text:00005555555555F6 movq    [rsp+160h+var_20], xmm14</span><br><span class="line">.text:0000555555555600 movq    [rsp+160h+var_10], xmm15</span><br><span class="line">.text:000055555555560A push    r12</span><br><span class="line">.text:000055555555560C mov     r12, rsp</span><br><span class="line">.text:000055555555560F sub     rsp, 10h</span><br><span class="line">.text:0000555555555613 and     rsp, 0FFFFFFFFFFFFFFF0h</span><br><span class="line">.text:0000555555555617 lea     rdi, _AFL_SHM_ENV               ; &quot;__AFL_SHM_ID&quot;</span><br><span class="line">.text:000055555555561E call    _getenv</span><br><span class="line">.text:000055555555561E</span><br><span class="line">.text:0000555555555623 test    rax, rax</span><br><span class="line">.text:0000555555555626 jz      __afl_setup_abort</span><br><span class="line">.text:0000555555555626</span><br><span class="line">.text:000055555555562C mov     rdi, rax                        ; nptr</span><br><span class="line">.text:000055555555562F call    _atoi</span><br><span class="line">.text:000055555555562F</span><br><span class="line">.text:0000555555555634 xor     rdx, rdx                        ; shmflg</span><br><span class="line">.text:0000555555555637 xor     rsi, rsi                        ; shmaddr</span><br><span class="line">.text:000055555555563A mov     rdi, rax                        ; shmid</span><br><span class="line">.text:000055555555563D call    _shmat</span><br><span class="line">.text:000055555555563D</span><br><span class="line">.text:0000555555555642 cmp     rax, 0FFFFFFFFFFFFFFFFh</span><br><span class="line">.text:0000555555555646 jz      __afl_setup_abort</span><br><span class="line">.text:0000555555555646</span><br><span class="line">.text:000055555555564C mov     byte ptr [rax], 1</span><br><span class="line">.text:000055555555564F mov     rdx, rax</span><br><span class="line">.text:0000555555555652 mov     cs:__afl_area_ptr, rax</span><br><span class="line">.text:0000555555555659 lea     rdx, __afl_global_area_ptr</span><br><span class="line">.text:0000555555555660 mov     [rdx], rax</span><br><span class="line">.text:0000555555555663 mov     rdx, rax</span><br></pre></td></tr></table></figure>

<p><code>__afl_setup_first</code>中开辟了160字节的栈帧,保存当前寄存器的状态.</p>
<p>获取环境变量<code>__AFL_SHM_ID</code>的值.该值是一个共享内存id,用于fuzz时不同进程之间的通信.</p>
<p>如果失败执行<code>__afl_setup_abort</code>:<code>__afl_setup_failure</code>自增,还原寄存器状态,释放栈,调用<code>__afl_return</code>还原,结束.</p>
<p>执行shmat获取<code>__AFL_SHM_ID</code>对应的共享内存,附加后,获取在本进程空间可以访问的地址.如果失败,则执行<code>__afl_setup_abort</code></p>
<p>在共享内存中写入1.将地址写入<code>_afl_area_ptr</code>和<code>_afl_global_area_ptr</code></p>
<p>而后开始执行<code>__afl_forkserver</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pushq %rdx</span><br><span class="line">pushq %rdx</span><br><span class="line">movq $4, %rdx               					/* length    */</span><br><span class="line">leaq __afl_temp(%rip), %rsi 					/* data      */</span><br><span class="line">movq $&quot; STRINGIFY((FORKSRV_FD + 1)) &quot;, %rdi       /* file desc */</span><br><span class="line">CALL_L64(&quot;write&quot;)</span><br><span class="line">cmpq $4, %rax</span><br><span class="line">jne  __afl_fork_resume</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Designated file descriptors for forkserver commands (the application will</span></span><br><span class="line"><span class="comment">   use FORKSRV_FD and FORKSRV_FD + 1): */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FORKSRV_FD          198</span></span><br></pre></td></tr></table></figure>

<p>将<code>__afl_temp</code>的值写入到指定的通信描述符中.<code>__afl_temp</code>实质上存储的是后面fork server的状态.这里如果写入失败将会跳转到<code>__afl_fork_resume</code>-&gt;<code>__afl_store</code>-&gt;<code>__afl_return</code></p>
<p><code>__afl_fork_resume</code>:释放资源,恢复寄存器状态</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.text:0000555555555531 48 8D 15 00 2B 00 00          lea     rdx, __afl_global_area_ptr</span><br><span class="line">.text:0000555555555538 48 8B 12                      mov     rdx, [rdx]</span><br><span class="line">.text:000055555555553B 48 85 D2                      test    rdx, rdx</span><br><span class="line">.text:000055555555553E 74 09                         jz      short __afl_setup_first</span><br><span class="line">.text:000055555555553E</span><br><span class="line">.text:0000555555555540 48 89 15 D1 2A 00 00          mov     cs:__afl_area_ptr, rdx</span><br><span class="line">.text:0000555555555547 EB B7                         jmp     short __afl_store</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.text:0000555555555500                               __afl_store:                            ; CODE XREF: __afl_maybe_log+57↓j</span><br><span class="line">.text:0000555555555500                                                                       ; __afl_maybe_log+314↓j</span><br><span class="line">.text:0000555555555500 48 33 0D 19 2B 00 00          xor     rcx, cs:__afl_prev_loc</span><br><span class="line">.text:0000555555555507 48 31 0D 12 2B 00 00          xor     cs:__afl_prev_loc, rcx</span><br><span class="line">.text:000055555555550E 48 D1 2D 0B 2B 00 00          shr     cs:__afl_prev_loc, 1</span><br><span class="line">.text:0000555555555515 80 04 0A 01                   add     byte ptr [rdx+rcx], 1</span><br><span class="line">.text:0000555555555519 80 14 0A 00                   adc     byte ptr [rdx+rcx], 0</span><br></pre></td></tr></table></figure>

<p><code>__afl_store</code>:</p>
<p>首先将当前桩的值(R(MAPSIZE))异或先前桩的值,然后右移1位.再将<code>__afl_prev_loc</code>异或这个值,然后将rcx中的值作为偏移<code>__afl_global_area_ptr</code>中指向的内存作为偏移,将此位置+1.</p>
<p>实际上在内存中形成了一个map结构,记录了分支执行次数,右移的目的是为了如果当前分支和上一个分支是一样的,xor的结果是0的情况.</p>
<p>还有一种情况时2个分支如果相互都存在执行关系的话,xor结果是一样的,右移后就可以区分了.</p>
<p><code>__afl_return</code>:恢复eflags寄存器状态</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">.text:000055555555568C                               __afl_fork_wait_loop:                   ; CODE XREF: __afl_maybe_log+22F↓j</span><br><span class="line">.text:000055555555568C 48 C7 C2 04 00 00 00          mov     rdx, 4                          ; nbytes</span><br><span class="line">.text:0000555555555693 48 8D 35 92 29 00 00          lea     rsi, __afl_temp                 ; buf</span><br><span class="line">.text:000055555555569A 48 C7 C7 C6 00 00 00          mov     rdi, 0C6h                       ; status</span><br><span class="line">.text:00005555555556A1 E8 CA FA FF FF                call    _read</span><br><span class="line">.text:00005555555556A1</span><br><span class="line">.text:00005555555556A6 48 83 F8 04                   cmp     rax, 4</span><br><span class="line">.text:00005555555556AA 0F 85 59 01 00 00             jnz     __afl_die</span><br><span class="line">.text:00005555555556AA</span><br><span class="line">.text:00005555555556B0 E8 2B FB FF FF                call    _fork</span><br><span class="line">.text:00005555555556B0</span><br><span class="line">.text:00005555555556B5 48 83 F8 00                   cmp     rax, 0</span><br><span class="line">.text:00005555555556B9 0F 8C 4A 01 00 00             jl      __afl_die</span><br><span class="line">.text:00005555555556B9</span><br><span class="line">.text:00005555555556BF 74 63                         jz      short __afl_fork_resume</span><br><span class="line">.text:00005555555556BF</span><br><span class="line">.text:00005555555556C1 89 05 61 29 00 00             mov     cs:__afl_fork_pid, eax</span><br><span class="line">.text:00005555555556C7 48 C7 C2 04 00 00 00          mov     rdx, 4                          ; n</span><br><span class="line">.text:00005555555556CE 48 8D 35 53 29 00 00          lea     rsi, __afl_fork_pid             ; buf</span><br><span class="line">.text:00005555555556D5 48 C7 C7 C7 00 00 00          mov     rdi, 0C7h                       ; fd</span><br><span class="line">.text:00005555555556DC E8 6F FA FF FF                call    _write</span><br><span class="line">.text:00005555555556DC</span><br><span class="line">.text:00005555555556E1 48 C7 C2 00 00 00 00          mov     rdx, 0                          ; options</span><br><span class="line">.text:00005555555556E8 48 8D 35 3D 29 00 00          lea     rsi, __afl_temp                 ; stat_loc</span><br><span class="line">.text:00005555555556EF 48 8B 3D 32 29 00 00          mov     rdi, qword ptr cs:__afl_fork_pid ; pid</span><br><span class="line">.text:00005555555556F6 E8 B5 FA FF FF                call    _waitpid</span><br><span class="line">.text:00005555555556F6</span><br><span class="line">.text:00005555555556FB 48 83 F8 00                   cmp     rax, 0</span><br><span class="line">.text:00005555555556FF 0F 8E 04 01 00 00             jle     __afl_die</span><br><span class="line">.text:00005555555556FF</span><br><span class="line">.text:0000555555555705 48 C7 C2 04 00 00 00          mov     rdx, 4                          ; n</span><br><span class="line">.text:000055555555570C 48 8D 35 19 29 00 00          lea     rsi, __afl_temp                 ; buf</span><br><span class="line">.text:0000555555555713 48 C7 C7 C7 00 00 00          mov     rdi, 0C7h                       ; fd</span><br><span class="line">.text:000055555555571A E8 31 FA FF FF                call    _write</span><br><span class="line">.text:000055555555571A</span><br><span class="line">.text:000055555555571F E9 68 FF FF FF                jmp     __afl_fork_wait_loop</span><br></pre></td></tr></table></figure>

<p>接着会执行<code>__afl_fork_wait_loop</code>的流程,中间如果遇到系统调用失败的问题,会跳转至<code>__afl_die</code>直接退出进程.</p>
<p>首先会阻塞读取指定的通信描述符<code>FORKSRV_FD</code>的值,,读取失败会结束进程,然后__fork一个子进程,它的作用在afl-fuzz.c中会体现,用于控制fork server.</p>
<p>子进程执行<code>__afl_fork_resume</code></p>
<p>当前进程:</p>
<p>当前进程将子进程id记录到<code>__afl_fork_pid</code>,将子进程id写入共享内存当中.</p>
<p>waitpid等待子进程执行完毕,并将status存储至<code>__afl_temp</code></p>
<p>然后将status信息写入共享内存.而后继续循环<code>__afl_fork_wait_loop</code>的流程.</p>
<p>子进程:</p>
<p>释放资源,恢复状态,继续向下执行代码</p>
<h2 id="4-afl-clang-fast"><a href="#4-afl-clang-fast" class="headerlink" title="4.afl-clang-fast"></a>4.afl-clang-fast</h2><p> afl-fast-clang与之前的afl-gcc实现思路是一样的,它是clang的一层封装</p>
<p>与afl-gcc不同的是,afl-fast-clang使用了llvm pass进行了插桩.</p>
<p>这也是afl-fuzz推荐的一种插桩和编译方式,因为llvm是模块化的,使用llvm pass可扩展性比较强.</p>
<p>之前分析过afl-gcc,afl-fast-clang与它功能一致,这里一些基本的函数就简单概述下,主要是分析下llvm pass的代码</p>
<h3 id="全局变量-2"><a href="#全局变量-2" class="headerlink" title="全局变量"></a>全局变量</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> u8*  obj_path;               <span class="comment">//LLVM PASS程序路径</span></span><br><span class="line"><span class="type">static</span> u8** cc_params;              <span class="comment">//clang参数</span></span><br><span class="line"><span class="type">static</span> u32  cc_par_cnt = <span class="number">1</span>;         <span class="comment">//clang参数数量</span></span><br></pre></td></tr></table></figure>



<h3 id="find-obj"><a href="#find-obj" class="headerlink" title="find_obj"></a>find_obj</h3><p>从环境变量<code>AFL_PATH</code>寻找<code>afl-llvm-rt.o</code>,或者从当前目录找,最后从AFL_PATH宏去找,找到后赋值obj_path.找不到报错.</p>
<h3 id="edit-params-2"><a href="#edit-params-2" class="headerlink" title="edit_params"></a>edit_params</h3><p>主要是设置clang的参数</p>
<p>通过当前执行afl-clang-fast&#x2F;afl-clang-fast++设置参数clang&#x2F;clang++,并设置环境变量AFL_CXX&#x2F;AFL_CC</p>
<p>而后load llvm pass插件afl-llvm-pass.so编译目标,传入插桩参数</p>
<p>根据传入参数,设置bit_mode,x_set,asan_set的值.</p>
<p>如果x_set的值为1,则设置参数为-x none</p>
<p>根据bit_mode的值,设置参数obj_path&#x2F;afl-llvm-rt-32.o或obj_path&#x2F;afl-llvm-rt-64.o,</p>
<p>默认为obj_path&#x2F;afl-llvm-rt.o</p>
<p>然后设置AFL运行时库<code>afl-llvm-rt.o</code>的一些宏.</p>
<h3 id="main-2"><a href="#main-2" class="headerlink" title="main"></a>main</h3><p>main函数在执行find_obj设置obj_path和调用edit_params设置参数后,执行execvp,参数如下</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -Xclang -load -Xclang /home/ash/code/afl-fuzz/afl-llvm-pass.so -Qunused-arguments ../testc.c -o ../testc.o -g -O3 -funroll-loops -D__AFL_HAVE_MANUAL_CONTROL=1 -D__AFL_COMPILER=1 -DFUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION=1 -D__AFL_LOOP(_A)=(&#123; static volatile char *_B __attribute__((used));  _B = (char*)&quot;##SIG_AFL_PERSISTENT##&quot;; __attribute__((visibility(&quot;default&quot;))) int _L(unsigned int) __asm__(&quot;__afl_persistent_loop&quot;); _L(_A); &#125;) -D__AFL_INIT()=do &#123; static volatile char *_A __attribute__((used));  _A = (char*)&quot;##SIG_AFL_DEFER_FORKSRV##&quot;; __attribute__((visibility(&quot;default&quot;))) void _I(void) __asm__(&quot;__afl_manual_init&quot;); _I(); &#125; while (0) /home/ash/code/afl-fuzz/afl-llvm-rt.o</span><br></pre></td></tr></table></figure>

<h3 id="llvm-pass代码分析"><a href="#llvm-pass代码分析" class="headerlink" title="llvm-pass代码分析"></a>llvm-pass代码分析</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">AFLCoverage</span> : <span class="keyword">public</span> ModulePass &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">      <span class="type">static</span> <span class="type">char</span> ID;</span><br><span class="line">      <span class="built_in">AFLCoverage</span>() : <span class="built_in">ModulePass</span>(ID) &#123; &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="type">bool</span> <span class="title">runOnModule</span><span class="params">(Module &amp;M)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// StringRef getPassName() const override &#123;</span></span><br><span class="line">      <span class="comment">//  return &quot;American Fuzzy Lop Instrumentation&quot;;</span></span><br><span class="line">      <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>afl-fuzz编写的pass名为AFLCoverage,以模块为单位对IR进行处理.重点看下runOnModule,看看是怎么对模块进行处理的.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">AFLCoverage::runOnModule</span><span class="params">(Module &amp;M)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  LLVMContext &amp;C = M.<span class="built_in">getContext</span>();</span><br><span class="line"></span><br><span class="line">  IntegerType *Int8Ty  = IntegerType::<span class="built_in">getInt8Ty</span>(C);</span><br><span class="line">  IntegerType *Int32Ty = IntegerType::<span class="built_in">getInt32Ty</span>(C);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Show a banner */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> be_quiet = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">isatty</span>(<span class="number">2</span>) &amp;&amp; !<span class="built_in">getenv</span>(<span class="string">&quot;AFL_QUIET&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">SAYF</span>(cCYA <span class="string">&quot;afl-llvm-pass &quot;</span> cBRI VERSION cRST <span class="string">&quot; by &lt;lszekeres@google.com&gt;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> be_quiet = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Decide instrumentation ratio */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">char</span>* inst_ratio_str = <span class="built_in">getenv</span>(<span class="string">&quot;AFL_INST_RATIO&quot;</span>);</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> inst_ratio = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (inst_ratio_str) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sscanf</span>(inst_ratio_str, <span class="string">&quot;%u&quot;</span>, &amp;inst_ratio) != <span class="number">1</span> || !inst_ratio ||</span><br><span class="line">        inst_ratio &gt; <span class="number">100</span>)</span><br><span class="line">      <span class="built_in">FATAL</span>(<span class="string">&quot;Bad value of AFL_INST_RATIO (must be between 1 and 100)&quot;</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Get globals for the SHM region and the previous location. Note that</span></span><br><span class="line"><span class="comment">     __afl_prev_loc is thread-local. */</span></span><br><span class="line"></span><br><span class="line">  GlobalVariable *AFLMapPtr =</span><br><span class="line">      <span class="keyword">new</span> <span class="built_in">GlobalVariable</span>(M, PointerType::<span class="built_in">get</span>(Int8Ty, <span class="number">0</span>), <span class="literal">false</span>,</span><br><span class="line">                         GlobalValue::ExternalLinkage, <span class="number">0</span>, <span class="string">&quot;__afl_area_ptr&quot;</span>);</span><br><span class="line"></span><br><span class="line">  GlobalVariable *AFLPrevLoc = <span class="keyword">new</span> <span class="built_in">GlobalVariable</span>(</span><br><span class="line">      M, Int32Ty, <span class="literal">false</span>, GlobalValue::ExternalLinkage, <span class="number">0</span>, <span class="string">&quot;__afl_prev_loc&quot;</span>,</span><br><span class="line">      <span class="number">0</span>, GlobalVariable::GeneralDynamicTLSModel, <span class="number">0</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Instrument all the things! */</span></span><br></pre></td></tr></table></figure>

<p>首先获取LLVM上下文对象,这个上下文对象LLVMContext时llvm用于管理一些信息和状态的,比如常量,函数,类型定义等.</p>
<p>然后通过上下文对象获取了2个整数类型的对象,分别是8为和32位的.</p>
<p>而后通过环境变量<code>AFL_QUIET</code>设置是否启用静默模式<code>be_quiet</code></p>
<p>读取环境变量<code>AFL_INST_RATIO</code>,设置插桩概率<code>inst_ratio</code>的值,默认为100.</p>
<p>而后通过LLVM的<code>GlobalVariable</code>类创建了2个全局变量</p>
<p><code>__afl_area_ptr</code>:8位,共享内存,记录桩执行信息</p>
<p><code>__afl_prev_loc</code>:32位,记录先前代码块</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> inst_blocks = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;F : M)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;BB : F) &#123;</span><br><span class="line"></span><br><span class="line">    BasicBlock::iterator IP = BB.<span class="built_in">getFirstInsertionPt</span>();</span><br><span class="line">    IRBuilder&lt;&gt; <span class="built_in">IRB</span>(&amp;(*IP));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">AFL_R</span>(<span class="number">100</span>) &gt;= inst_ratio) <span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure>

<p>通过<code>inst_blocks</code>变量记录插桩的基本块数量.</p>
<p>然后遍历每个基本块进行处理.</p>
<p>而后通过<code>BB.getFirstInsertionPt();</code>从基本块头部开始获取可插入点位置,而后作为构造参数创建了<code>IRBuilder</code>对象,用于后面创建和插入指令.</p>
<p>首先生成100内的随机数是否大于<code>inst_ratio</code>,大于则跳过不做处理.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Make up cur_loc */</span></span><br><span class="line"></span><br><span class="line">   <span class="type">unsigned</span> <span class="type">int</span> cur_loc = <span class="built_in">AFL_R</span>(MAP_SIZE);</span><br><span class="line"></span><br><span class="line">   ConstantInt *CurLoc = ConstantInt::<span class="built_in">get</span>(Int32Ty, cur_loc);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* Load prev_loc */</span></span><br><span class="line"></span><br><span class="line">   LoadInst *PrevLoc = IRB.<span class="built_in">CreateLoad</span>(AFLPrevLoc);</span><br><span class="line">   PrevLoc-&gt;<span class="built_in">setMetadata</span>(M.<span class="built_in">getMDKindID</span>(<span class="string">&quot;nosanitize&quot;</span>), MDNode::<span class="built_in">get</span>(C, None));</span><br><span class="line">   Value *PrevLocCasted = IRB.<span class="built_in">CreateZExt</span>(PrevLoc, IRB.<span class="built_in">getInt32Ty</span>());</span><br></pre></td></tr></table></figure>

<p>而后获取了一个随机数,并通过<code>ConstantInt::get</code>将这个随机数创建为常量.</p>
<p>然后创建了读取指令用于读取<code>AFLPrevLoc</code>的值,获取前一个基本块的编号,并将这个这个指令设置了一个<code>nosanitize</code>的属性,并且后面的一些读取指令都加了这个属性,作用应该是编译时,跳过对该指令的一些安全检查,提高fuzz速度.然后创建零扩展指令,对结果进行零扩展.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Load SHM pointer */</span></span><br><span class="line"></span><br><span class="line">     LoadInst *MapPtr = IRB.<span class="built_in">CreateLoad</span>(AFLMapPtr);</span><br><span class="line">     MapPtr-&gt;<span class="built_in">setMetadata</span>(M.<span class="built_in">getMDKindID</span>(<span class="string">&quot;nosanitize&quot;</span>), MDNode::<span class="built_in">get</span>(C, None));</span><br><span class="line">     Value *MapPtrIdx =</span><br><span class="line">         IRB.<span class="built_in">CreateGEP</span>(MapPtr, IRB.<span class="built_in">CreateXor</span>(PrevLocCasted, CurLoc));</span><br></pre></td></tr></table></figure>

<p>而后创建如下获取共享内存中指定内存地址的操作指令:</p>
<p>创建读取指令读取<code>AFLMapPtr</code>,也就是共享内存,然后通过当前基本块id xor前一个基本块id的结果作为偏移,以<code>AFLMapPtr</code>作为基址,获取对应的内存地址.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Update bitmap */</span></span><br><span class="line">  LoadInst *Counter = IRB.<span class="built_in">CreateLoad</span>(MapPtrIdx);</span><br><span class="line">  Counter-&gt;<span class="built_in">setMetadata</span>(M.<span class="built_in">getMDKindID</span>(<span class="string">&quot;nosanitize&quot;</span>), MDNode::<span class="built_in">get</span>(C, None));</span><br><span class="line">  Value *Incr = IRB.<span class="built_in">CreateAdd</span>(Counter, ConstantInt::<span class="built_in">get</span>(Int8Ty, <span class="number">1</span>));</span><br><span class="line">  IRB.<span class="built_in">CreateStore</span>(Incr, MapPtrIdx)</span><br><span class="line">      -&gt;<span class="built_in">setMetadata</span>(M.<span class="built_in">getMDKindID</span>(<span class="string">&quot;nosanitize&quot;</span>), MDNode::<span class="built_in">get</span>(C, None));</span><br></pre></td></tr></table></figure>

<p>而后创建向上一步获取的内存地址中的数据进行自增的操作指令:</p>
<p>获取内存里的数据,自增之后,再写入.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Set prev_loc to cur_loc &gt;&gt; 1 */</span></span><br><span class="line"></span><br><span class="line">      StoreInst *Store =</span><br><span class="line">          IRB.<span class="built_in">CreateStore</span>(ConstantInt::<span class="built_in">get</span>(Int32Ty, cur_loc &gt;&gt; <span class="number">1</span>), AFLPrevLoc);</span><br><span class="line">      Store-&gt;<span class="built_in">setMetadata</span>(M.<span class="built_in">getMDKindID</span>(<span class="string">&quot;nosanitize&quot;</span>), MDNode::<span class="built_in">get</span>(C, None));</span><br><span class="line"></span><br><span class="line">      inst_blocks++;</span><br></pre></td></tr></table></figure>

<p>然后将当前的基本块id右移1位,写入至<code>AFLPrevLoc</code>,插桩的基本块计数+1.</p>
<p>右移的目的是为了解决出现以下两种情况存在的问题:</p>
<p>1.如果当前基本块和上一个基本块是一样的,xor的结果是0的情况.</p>
<p>2.如果2个基本块相互存在控制流关系的话,无论从哪个基本块执行到目标基本块,xor结果是一样的,右移后就可以进行区分了.</p>
<p>与前面的afl-as中插桩的代码一样,都是对插桩的基本块执行次数进行了记录,实现覆盖率的反馈.</p>
<h3 id="afl-llvm-rt-o-c-分析"><a href="#afl-llvm-rt-o-c-分析" class="headerlink" title="afl-llvm-rt.o.c 分析"></a>afl-llvm-rt.o.c 分析</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -Xclang -load -Xclang /home/ash/code/afl-fuzz/afl-llvm-pass.so -Qunused-arguments ../testc.c -o ../testc.o -g -O3 -funroll-loops -D__AFL_HAVE_MANUAL_CONTROL=1 -D__AFL_COMPILER=1 -DFUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION=1 -D__AFL_LOOP(_A)=(&#123; static volatile char *_B __attribute__((used));  _B = (char*)&quot;##SIG_AFL_PERSISTENT##&quot;; __attribute__((visibility(&quot;default&quot;))) int _L(unsigned int) __asm__(&quot;__afl_persistent_loop&quot;); _L(_A); &#125;) -D__AFL_INIT()=do &#123; static volatile char *_A __attribute__((used));  _A = (char*)&quot;##SIG_AFL_DEFER_FORKSRV##&quot;; __attribute__((visibility(&quot;default&quot;))) void _I(void) __asm__(&quot;__afl_manual_init&quot;); _I(); &#125; while (0) /home/ash/code/afl-fuzz/afl-llvm-rt.o</span><br></pre></td></tr></table></figure>

<p>这是afl-clang-fast最终传至clang的参数,包含AFL的运行时库,和一些宏,可以使用llvm mode下的一些额外功能,这部分代码在afl-llvm-rt.o.c中.</p>
<p>首先是初始化的代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((<span class="built_in">constructor</span>(CONST_PRIO))) <span class="type">void</span> __afl_auto_init(<span class="type">void</span>) &#123;</span><br><span class="line"></span><br><span class="line">  is_persistent = !!<span class="built_in">getenv</span>(PERSIST_ENV_VAR);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">getenv</span>(DEFER_ENV_VAR)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  __afl_manual_init();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>被<code>__attribute__((constructor(CONST_PRIO)))</code>所修饰的函数会在程序启动时优先调用,可以确定的是它是在main函数之前调用,可以定义多个这种类型的函数,其中<code>CONST_PRIO</code>表示执行的优先级,</p>
<p>首先获取环境变量<code>PERSIST_ENV_VAR</code>,赋值给<code>is_persistent</code>,用于标识<code>persistent mode</code>模式,然后获取环境变量<code>DEFER_ENV_VAR</code>,如果为true,直接return,这个标志的作用是标识是否延迟fork server</p>
<p>否则执行<code>__afl_manual_init();</code>函数,这个函数内部会初始化共享内存和fork server,下面会详细分析.</p>
<p>这样设计的目的是因为在<code>deferred instrumentation</code>模式下,需要延迟fork server,所以会自己定义初始化的位置.不需要自动初始化.</p>
<p>所以这段代码是为了兼容额外模式做的处理.</p>
<p>afl的文档中介绍了3种额外功能模式</p>
<h4 id="1-deferred-instrumentation"><a href="#1-deferred-instrumentation" class="headerlink" title="1.deferred instrumentation"></a>1.deferred instrumentation</h4><p>afl会只执行一次目标二进制文件,在执行某个位置之前停止,然后克隆进程进行持续而稳定的fuzz,这种fuzz的方式减少了大部分操作系统的链接和libc成本,据官方所说,某些情况下可以将性能提高10倍以上.</p>
<p>使用方法:</p>
<p>在代码中找到需要进行暂停,然后克隆进程的位置,需要注意的是,这个位置尽量避免访问和创建一些资源,比如创建线程进程,定时器,临时文件,网络套接字等.</p>
<p>在选好合适的位置后,添加如下代码,然后再使用afl-clang-fast重新编译,它是不支持afl-gcc和afl-clang的.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __AFL_HAVE_MANUAL_CONTROL</span></span><br><span class="line">  __AFL_INIT();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cc_params[cc_par_cnt++] = <span class="string">&quot;-D__AFL_INIT()=&quot;</span></span><br><span class="line">                          <span class="string">&quot;do &#123; static volatile char *_A __attribute__((used)); &quot;</span></span><br><span class="line">                          <span class="string">&quot; _A = (char*)\&quot;&quot;</span> DEFER_SIG <span class="string">&quot;\&quot;; &quot;</span></span><br><span class="line">                          <span class="meta">#<span class="keyword">ifdef</span> __APPLE__</span></span><br><span class="line">                          <span class="string">&quot;__attribute__((visibility(\&quot;default\&quot;))) &quot;</span></span><br><span class="line"><span class="string">&quot;void _I(void) __asm__(\&quot;___afl_manual_init\&quot;); &quot;</span></span><br><span class="line">                          <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">                          <span class="string">&quot;__attribute__((visibility(\&quot;default\&quot;))) &quot;</span></span><br><span class="line">                          <span class="string">&quot;void _I(void) __asm__(\&quot;__afl_manual_init\&quot;); &quot;</span></span><br><span class="line">                          <span class="meta">#<span class="keyword">endif</span> <span class="comment">/* ^__APPLE__ */</span></span></span><br><span class="line">                          <span class="string">&quot;_I(); &#125; while (0)&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>在之前的afl-clang-fast.c中可以看到<code>__AFL_INIT();</code>实际执行的函数应是<code>__afl_manual_init</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __afl_manual_init(<span class="type">void</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">static</span> u8 init_done;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!init_done) &#123;</span><br><span class="line"></span><br><span class="line">    __afl_map_shm();</span><br><span class="line">    __afl_start_forkserver();</span><br><span class="line">    init_done = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果没有进行初始化就会执行<code> __afl_map_shm();</code>,<code>__afl_start_forkserver();</code>进行初始化.</p>
<p><code>__afl_map_shm</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __afl_map_shm(<span class="type">void</span>) &#123;</span><br><span class="line"></span><br><span class="line">  u8 *id_str = <span class="built_in">getenv</span>(SHM_ENV_VAR);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* If we&#x27;re running under AFL, attach to the appropriate region, replacing the</span></span><br><span class="line"><span class="comment">     early-stage __afl_area_initial region that is needed to allow some really</span></span><br><span class="line"><span class="comment">     hacky .init code to work correctly in projects such as OpenSSL. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (id_str) &#123;</span><br><span class="line"></span><br><span class="line">    u32 shm_id = <span class="built_in">atoi</span>(id_str);</span><br><span class="line"></span><br><span class="line">    __afl_area_ptr = <span class="built_in">shmat</span>(shm_id, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Whooooops. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__afl_area_ptr == (<span class="type">void</span> *)<span class="number">-1</span>) _exit(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Write something into the bitmap so that even with low AFL_INST_RATIO,</span></span><br><span class="line"><span class="comment">       our parent doesn&#x27;t give up on us. */</span></span><br><span class="line"></span><br><span class="line">    __afl_area_ptr[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数是获取共享内存的,前面afl-as中桩代码中也有这部分逻辑,就不会赘述了.</p>
<p><code>__afl_start_forkserver();</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __afl_start_forkserver(<span class="type">void</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">static</span> u8 tmp[<span class="number">4</span>];</span><br><span class="line">  s32 child_pid;</span><br><span class="line"></span><br><span class="line">  u8  child_stopped = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Phone home and tell the parent that we&#x27;re OK. If parent isn&#x27;t there,</span></span><br><span class="line"><span class="comment">     assume we&#x27;re not running in forkserver mode and just execute program. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">write</span>(FORKSRV_FD + <span class="number">1</span>, tmp, <span class="number">4</span>) != <span class="number">4</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">    u32 was_killed;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Wait for parent by reading from the pipe. Abort if read fails. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">read</span>(FORKSRV_FD, &amp;was_killed, <span class="number">4</span>) != <span class="number">4</span>) _exit(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If we stopped the child in persistent mode, but there was a race</span></span><br><span class="line"><span class="comment">       condition and afl-fuzz already issued SIGKILL, write off the old</span></span><br><span class="line"><span class="comment">       process. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (child_stopped &amp;&amp; was_killed) &#123;</span><br><span class="line">      child_stopped = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">waitpid</span>(child_pid, &amp;status, <span class="number">0</span>) &lt; <span class="number">0</span>) _exit(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!child_stopped) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Once woken up, create a clone of our process. */</span></span><br><span class="line"></span><br><span class="line">      child_pid = fork();</span><br><span class="line">      <span class="keyword">if</span> (child_pid &lt; <span class="number">0</span>) _exit(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* In child process: close fds, resume execution. */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!child_pid) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">close</span>(FORKSRV_FD);</span><br><span class="line">        <span class="built_in">close</span>(FORKSRV_FD + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">  </span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Special handling for persistent mode: if the child is alive but</span></span><br><span class="line"><span class="comment">         currently stopped, simply restart it with SIGCONT. */</span></span><br><span class="line"></span><br><span class="line">      <span class="built_in">kill</span>(child_pid, SIGCONT);</span><br><span class="line">      child_stopped = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* In parent process: write PID to pipe, then wait for child. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">write</span>(FORKSRV_FD + <span class="number">1</span>, &amp;child_pid, <span class="number">4</span>) != <span class="number">4</span>) _exit(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">waitpid</span>(child_pid, &amp;status, is_persistent ? WUNTRACED : <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">      _exit(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* In persistent mode, the child stops itself with SIGSTOP to indicate</span></span><br><span class="line"><span class="comment">       a successful run. In this case, we want to wake it up without forking</span></span><br><span class="line"><span class="comment">       again. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">WIFSTOPPED</span>(status)) child_stopped = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Relay wait status to pipe, then loop back. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">write</span>(FORKSRV_FD + <span class="number">1</span>, &amp;status, <span class="number">4</span>) != <span class="number">4</span>) _exit(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先设置child_stopped为0.</p>
<p>向通信描述符<code>FORKSRV_FD + 1</code>中写入数据,实质上这里存储的是后面fork server的状态.</p>
<p>然后开始循环</p>
<p>从<code>FORKSRV_FD</code>中阻塞读取,读取到数据继续向下执行.</p>
<p>这里的<code>FORKSRV_FD</code>和<code>FORKSRV_FD + 1</code>在afl-fuzz.c的init_forkserver函数进行了初始化,将st_pipe和ctl_pipe两个管道分别复制给了<code>FORKSRV_FD</code>和<code>FORKSRV_FD + 1</code>.</p>
<p><code>FORKSRV_FD</code>是用于控制fork server的通信管道.</p>
<p><code>FORKSRV_FD + 1</code>内写入了一些fork server的状态信息,afl-fuzz.c内会进行读取.</p>
<p>这两个管道的作用会在afl-fuzz.c中体现.</p>
<p>判断<code>child_stopped</code>和<code>was_killed</code>不为0,这两个值表示子进程是否停止和子进程是否被杀死.</p>
<p>​	如果为true,则表示子进程已经停止,并且之前被杀死,然后将<code>child_stopped</code>复位为0,并等待子进程退出状态.</p>
<p>继续判断<code>child_stopped</code>状态.</p>
<p>​	如果为0,则fork一个子进程,进行fuzz,释放当前管道资源,return.</p>
<p>​	如果为1,这是persistent mode的特殊处理,此时子进程处于暂停状态,通过<code>kill(child_pid, SIGCONT);</code>函数对	子进程进行重启.然后将<code>child_stopped</code>复位为0.</p>
<p>向<code>FORKSRV_FD + 1</code>中写入子进程id,然后等待子进程结束.</p>
<p>对<code>persistent mode</code>下进行特殊处理,该模式下,子进程会通过sigstop自行停止指示运行成功,这种情况下需要唤醒它进行fuzz,所以将child_stopped状态更改为1,会执行到之前的步骤,继续运行.</p>
<p>将状态写入至<code>FORKSRV_FD + 1</code>至,继续循环.</p>
<h4 id="2-persistent-mode"><a href="#2-persistent-mode" class="headerlink" title="2.persistent mode"></a>2.persistent mode</h4><p><code>persistent mode</code>模式在单个进程中通过测试用例进行fuzz,通过使用一些不影响上下文状态的api,和处理输入文件进行fuzz时,进行状态的重置,可以重用一个进程进行持续的fuzz,不需要fork新的进程,节省了资源的开销,提高了效率.</p>
<p>使用方式是通过下面的宏.</p>
<p>需要读取测试用例,调用目标模块,然后恢复一些状态,这些代码都要自己实现.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (__AFL_LOOP(<span class="number">1000</span>)) &#123;</span><br><span class="line">  <span class="comment">/* Read input data. */</span></span><br><span class="line">  <span class="comment">/* Call library code to be fuzzed. */</span></span><br><span class="line">  <span class="comment">/* Reset state. */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Exit normally */</span></span><br></pre></td></tr></table></figure>

<p>这种模式之前在一篇adobe漏洞挖掘的文章里见到过,使用该模式挖掘Jp2k类型图片的解析模块,挖掘者逆向了adobe解析jp2k图片的一个最底层的函数,逆向了该函数的参数,然后进行模拟构造,再进行调用,最大限度的提高效率,挖出了大量漏洞.</p>
<p>在afl-fuzz的文档说明循环次数最好为1000,目的是减少内存泄漏和一些其他问题带来的影响.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cc_params[cc_par_cnt++] = <span class="string">&quot;-D__AFL_LOOP(_A)=&quot;</span></span><br><span class="line">                          <span class="string">&quot;(&#123; static volatile char *_B __attribute__((used)); &quot;</span></span><br><span class="line">                          <span class="string">&quot; _B = (char*)\&quot;&quot;</span> PERSIST_SIG <span class="string">&quot;\&quot;; &quot;</span></span><br><span class="line">                          <span class="meta">#<span class="keyword">ifdef</span> __APPLE__</span></span><br><span class="line">                          <span class="string">&quot;__attribute__((visibility(\&quot;default\&quot;))) &quot;</span></span><br><span class="line"><span class="string">&quot;int _L(unsigned int) __asm__(\&quot;___afl_persistent_loop\&quot;); &quot;</span></span><br><span class="line">                          <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">                          <span class="string">&quot;__attribute__((visibility(\&quot;default\&quot;))) &quot;</span></span><br><span class="line">                          <span class="string">&quot;int _L(unsigned int) __asm__(\&quot;__afl_persistent_loop\&quot;); &quot;</span></span><br><span class="line">                          <span class="meta">#<span class="keyword">endif</span> <span class="comment">/* ^__APPLE__ */</span></span></span><br><span class="line">                          <span class="string">&quot;_L(_A); &#125;)&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>这里<code>__AFL_LOOP(_A)</code>对应的函数是<code>__afl_persistent_loop</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __afl_persistent_loop(<span class="type">unsigned</span> <span class="type">int</span> max_cnt) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">static</span> u8  first_pass = <span class="number">1</span>;</span><br><span class="line">  <span class="type">static</span> u32 cycle_cnt;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (first_pass) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Make sure that every iteration of __AFL_LOOP() starts with a clean slate.</span></span><br><span class="line"><span class="comment">       On subsequent calls, the parent will take care of that, but on the first</span></span><br><span class="line"><span class="comment">       iteration, it&#x27;s our job to erase any trace of whatever happened</span></span><br><span class="line"><span class="comment">       before the loop. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (is_persistent) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">memset</span>(__afl_area_ptr, <span class="number">0</span>, MAP_SIZE);</span><br><span class="line">      __afl_area_ptr[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">      __afl_prev_loc = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cycle_cnt  = max_cnt;</span><br><span class="line">    first_pass = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (is_persistent) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (--cycle_cnt) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">raise</span>(SIGSTOP);</span><br><span class="line"></span><br><span class="line">      __afl_area_ptr[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">      __afl_prev_loc = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* When exiting __AFL_LOOP(), make sure that the subsequent code that</span></span><br><span class="line"><span class="comment">         follows the loop is not traced. We do that by pivoting back to the</span></span><br><span class="line"><span class="comment">         dummy output region. */</span></span><br><span class="line"></span><br><span class="line">      __afl_area_ptr = __afl_area_initial;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这块代码需要结合之前的代码整体看下,</p>
<p>执行顺序是<code>afl_auto_init-&gt;__afl_manual_init-&gt;__afl_start_forkserver-&gt;__afl_persistent_loop</code></p>
<p>初始化共享内存,然后进行fork server</p>
<p>然后执行到这个函数<code>__afl_persistent_loop</code>:</p>
<p>函数参数是<code>max_cnt</code>,最大循环次数.</p>
<p>首先定义了两个变量</p>
<p><code>first_pass</code>初始化为1,表示是否为第一次执行.</p>
<p><code>cycle_cnt</code>表示剩余循环次数.</p>
<p>如果是第一次执行会,清空<code>__afl_area_ptr</code>,<code>__afl_area_ptr[0]</code>设置为1,然后将<code>__afl_prev_loc</code>设置为0.</p>
<p>然后将初始化<code>cycle_cnt</code>设置为最大循环次数.first_pass修改为0,return 1.</p>
<p>如果不是第一次执行.</p>
<p>判断<code>is_persistent</code>当前是否为<code>persistent mode</code>,不是return 0.</p>
<p>然后<code>cycle_cnt</code>减1,判断剩余次数是否为0.</p>
<p>​		如果不为0,则通过<code>raise(SIGSTOP)</code>,让当前进程暂停,<code>__afl_area_ptr[0]</code>设置为1,然后将<code>__afl_prev_loc</code>设置为0.return 1.此时在fork server会设置child_stopped标志位,然后再下次时,会恢复之前的子进程执行.</p>
<p>​		如果为0,则将<code>__afl_area_ptr</code>指向<code>__afl_area_initial</code>,它是空的.</p>
<h2 id="5-af-fuzz"><a href="#5-af-fuzz" class="headerlink" title="5.af-fuzz"></a>5.af-fuzz</h2>
    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/04/26/winafl%E6%90%AD%E5%BB%BA/" rel="prev" title="winafl搭建">
      <i class="fa fa-chevron-left"></i> winafl搭建
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/05/23/LLVM%20pass%E5%AD%A6%E4%B9%A0/" rel="next" title="LLVM 代码混淆技术">
      LLVM 代码混淆技术 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#afl-fuzz%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">1.</span> <span class="nav-text">afl-fuzz源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#GCC%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B"><span class="nav-number">1.1.</span> <span class="nav-text">GCC编译流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-afl-gcc"><span class="nav-number">1.2.</span> <span class="nav-text">1.afl-gcc</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="nav-number">1.2.1.</span> <span class="nav-text">全局变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#main"><span class="nav-number">1.2.2.</span> <span class="nav-text">main</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#find-as"><span class="nav-number">1.2.3.</span> <span class="nav-text">find_as</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#edit-params"><span class="nav-number">1.2.4.</span> <span class="nav-text">edit_params</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#execvp-cc-params-0-char-cc-params"><span class="nav-number">1.2.5.</span> <span class="nav-text">execvp(cc_params[0], (char**)cc_params);</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-afl-as"><span class="nav-number">1.3.</span> <span class="nav-text">2.afl-as</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F-1"><span class="nav-number">1.3.1.</span> <span class="nav-text">全局变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#main-1"><span class="nav-number">1.3.2.</span> <span class="nav-text">main</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#edit-params-1"><span class="nav-number">1.3.3.</span> <span class="nav-text">edit_params</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#add-instrumentation"><span class="nav-number">1.3.4.</span> <span class="nav-text">add_instrumentation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#afl-as%E6%A1%A9%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">1.3.5.</span> <span class="nav-text">afl-as桩代码分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-afl-clang-fast"><span class="nav-number">1.4.</span> <span class="nav-text">4.afl-clang-fast</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F-2"><span class="nav-number">1.4.1.</span> <span class="nav-text">全局变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#find-obj"><span class="nav-number">1.4.2.</span> <span class="nav-text">find_obj</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#edit-params-2"><span class="nav-number">1.4.3.</span> <span class="nav-text">edit_params</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#main-2"><span class="nav-number">1.4.4.</span> <span class="nav-text">main</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#llvm-pass%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">1.4.5.</span> <span class="nav-text">llvm-pass代码分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#afl-llvm-rt-o-c-%E5%88%86%E6%9E%90"><span class="nav-number">1.4.6.</span> <span class="nav-text">afl-llvm-rt.o.c 分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-deferred-instrumentation"><span class="nav-number">1.4.6.1.</span> <span class="nav-text">1.deferred instrumentation</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-persistent-mode"><span class="nav-number">1.4.6.2.</span> <span class="nav-text">2.persistent mode</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-af-fuzz"><span class="nav-number">1.5.</span> <span class="nav-text">5.af-fuzz</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Ash</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">13</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ash</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
